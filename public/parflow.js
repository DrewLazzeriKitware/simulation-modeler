/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/index.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/babel-loader/lib/index.js?!./build/index.js":
/*!*******************************************************************************************************************************!*\
  !*** /home/drew/.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/babel-loader/lib??ref--9-0!./build/index.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";\nmodule.exports = {\n  type: 'parflow',\n  model: __webpack_require__(/*! ./model.json */ \"./build/model.json\"),\n  lang: {},\n  convert: __webpack_require__(/*! ./convert.js */ \"./build/convert.js\"),\n  hooks: __webpack_require__(/*! ./hooks.js */ \"./build/hooks.js\"),\n  parse: null\n};\n\n//# sourceURL=webpack:///./build/index.js?/home/drew/.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/babel-loader/lib??ref--9-0");

/***/ }),

/***/ "../../../.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./build/convert.js":
/*!**************************!*\
  !*** ./build/convert.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function (dataModel) {\n  var pftools = {};\n  Object.values(dataModel.data).forEach(function (views) {\n    views.forEach(function (view) {\n      return addView(pftools, view);\n    });\n  });\n  return {\n    pftools: pftools,\n    dataModel: dataModel\n  };\n};\n\nfunction addView(pftools, view) {\n  // Find dynamic names if dynamic view\n  var dynamicKey = null;\n  var dynamicName = null;\n  var attributes = Object.values(view).filter(function (attribute) {\n    return typeof attribute !== \"string\";\n  });\n\n  if (attributes.length == 1) {\n    var isNameId = function isNameId(_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          key = _ref2[0];\n\n      return key.indexOf(\"/\") === -1;\n    };\n\n    var name = Object.entries(attributes[0]).find(isNameId);\n\n    if (name) {\n      var _name = _slicedToArray(name, 2),\n          nameId = _name[0],\n          nameProp = _name[1];\n\n      if (nameProp.value[0]) {\n        dynamicName = nameProp.value[0];\n        dynamicKey = nameId;\n      }\n    }\n  }\n\n  Object.values(view).forEach(function (properties) {\n    Object.entries(properties).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          propertyName = _ref4[0],\n          property = _ref4[1];\n\n      if (propertyName.indexOf(\"/\") === -1) return;\n      var pftoolsName = propertyName.replaceAll(\"/\", \".\");\n\n      if (dynamicKey && dynamicName) {\n        pftoolsName = pftoolsName.replaceAll(dynamicKey, dynamicName);\n      }\n\n      if (property.value.length > 1) {\n        console.error(\"Encountered property with length > 1\", property);\n        return;\n      }\n\n      if (!property.value[0]) {\n        return;\n      }\n\n      if (property.value[0].rows) {\n        addTable(pftools, property.value[0].rows, dynamicKey, dynamicName);\n        return;\n      }\n\n      pftools[pftoolsName] = property.value[0];\n    });\n  });\n}\n\nfunction addTable(pftools, rows, dynamicKey, dynamicName) {\n  rows.forEach(function (row) {\n    Object.entries(row.rowValues).forEach(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          propertyName = _ref6[0],\n          property = _ref6[1];\n\n      // Redo naming for properties in table\n      var pftoolsName = propertyName.replaceAll(\"/\", \".\");\n\n      if (dynamicKey && dynamicName) {\n        pftoolsName = pftoolsName.replaceAll(dynamicKey, dynamicName);\n      }\n\n      Object.entries(row.rowKeys).forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            rowKey = _ref8[0],\n            rowName = _ref8[1];\n\n        var _rowKey$split = rowKey.split(\"/\"),\n            l = _rowKey$split.length,\n            rowKind = _rowKey$split[l - 1];\n\n        pftoolsName = pftoolsName.replaceAll(rowKind, rowName);\n      });\n\n      if (property.data.value.length > 1) {\n        console.error(\"Encountered property with length > 1\", property);\n        return;\n      }\n\n      if (!property.data.value[0]) {\n        return;\n      }\n\n      pftools[pftoolsName] = property.data.value[0];\n    });\n  });\n}\n\n//# sourceURL=webpack:///./build/convert.js?");

/***/ }),

/***/ "./build/hooks.js":
/*!************************!*\
  !*** ./build/hooks.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// import EnumDomainUpdate from \"./EnumDomainUpdate.js\";\n// import VariableTableUpdate from \"./VariableTableUpdate.js\";\nmodule.exports = function initialize(Simput) {\n  Simput.registerHook(\"ReadNamesWriteTableHook\", function (hookConfig, dataModel, currentViewData, modelDefinition) {\n    // When dynamic tokens are updated, update all their children\n    var update = new VariableTableUpdate({\n      hookConfig: hookConfig,\n      dataModel: dataModel,\n      currentViewData: currentViewData,\n      modelDefinition: modelDefinition\n    });\n    update.run();\n  });\n  Simput.registerHook(\"ReadLocationsWriteDomainHook\", function (hookConfig, dataModel, currentViewData, modelDefinition) {\n    var update = new EnumDomainUpdate({\n      hookConfig: hookConfig,\n      dataModel: dataModel,\n      currentViewData: currentViewData,\n      modelDefinition: modelDefinition\n    });\n    update.run();\n  });\n};\n\nvar EnumDomainUpdate = /*#__PURE__*/function () {\n  function EnumDomainUpdate(hookParams) {\n    _classCallCheck(this, EnumDomainUpdate);\n\n    var hookConfig = hookParams.hookConfig,\n        dataModel = hookParams.dataModel,\n        modelDefinition = hookParams.modelDefinition,\n        currentViewData = hookParams.currentViewData;\n    var source_id = hookConfig.source_id,\n        dependant_domains = hookConfig.dependant_domains;\n    var external = dataModel.external;\n    Object.assign(this, {\n      modelDefinition: modelDefinition,\n      dataModel: dataModel,\n      source_id: source_id,\n      currentViewData: currentViewData,\n      dependant_domains: dependant_domains,\n      external: external\n    });\n  }\n\n  _createClass(EnumDomainUpdate, [{\n    key: \"run\",\n    value: function run() {\n      for (var a in this.currentViewData) {\n        var attr = this.currentViewData[a];\n\n        for (var p in attr) {\n          if (p === this.source_id) {\n            var param = attr[p];\n            var found = this.findNewDomain(param);\n\n            if (found) {\n              this.copySourceToDomains();\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"findNewDomain\",\n    value: function findNewDomain(param) {\n      if (param.value[0]) {\n        var source = param.value[0].split(\" \");\n        this.newDomain = source.reduce(function (acc, domainOption) {\n          return _objectSpread(_defineProperty({}, domainOption, domainOption), acc);\n        }, {});\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setNewDomain\",\n    value: function setNewDomain(destination) {\n      this.external[\"EnumDomain/\".concat(destination)] = this.newDomain;\n    }\n  }, {\n    key: \"copySourceToDomains\",\n    value: function copySourceToDomains() {\n      for (var d in this.dependant_domains) {\n        var dependantKey = this.dependant_domains[d];\n        this.setNewDomain(dependantKey);\n      }\n    }\n  }]);\n\n  return EnumDomainUpdate;\n}();\n\nvar VariableTableUpdate = /*#__PURE__*/function () {\n  function VariableTableUpdate(hookParams) {\n    _classCallCheck(this, VariableTableUpdate);\n\n    var hookConfig = hookParams.hookConfig,\n        dataModel = hookParams.dataModel,\n        modelDefinition = hookParams.modelDefinition;\n    var variable_column_id = hookConfig.variable_column_id,\n        table_attr = hookConfig.table_attr,\n        names_id = hookConfig.names_id,\n        names_view = hookConfig.names_view,\n        names_attr = hookConfig.names_attr,\n        match_condition = hookConfig.match_condition; // Find where new names need to go\n\n    var table_view = this.findTargetViewName(dataModel, table_attr);\n    var external = dataModel.external;\n    Object.assign(this, {\n      modelDefinition: modelDefinition,\n      dataModel: dataModel,\n      external: external,\n      names_view: names_view,\n      names_id: names_id,\n      names_attr: names_attr,\n      table_view: table_view,\n      table_attr: table_attr,\n      variable_column_id: variable_column_id,\n      match_condition: match_condition\n    });\n  }\n\n  _createClass(VariableTableUpdate, [{\n    key: \"run\",\n    value: function run() {\n      var nameSources = this.readNames(); // We generate table rows from combining all their names,\n      // subtract those who aren't sparse\n      // and subtract matche_conditions\n\n      var restrictions = this.getSparseRestrictions();\n\n      if (this.match_condition) {\n        restrictions = restrictions.concat(this.getMatchRestrictions(this.match_condition, this.table_view, this.table_attr, this.dataModel));\n      }\n\n      var prefix_key = \"VariableTableDomain/\".concat(this.variable_column_id);\n\n      for (var extTableId in this.external) {\n        if (extTableId.startsWith(prefix_key)) {\n          // Only update tables that depend on this dynamic variable\n          this.updateTableDomain(extTableId, nameSources);\n\n          if (this.shouldOverwriteTable(extTableId)) {\n            this.writeTableToProp(extTableId, nameSources, restrictions);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateTableDomain\",\n    value: function updateTableDomain(extTableId, nameSources) {\n      var _this = this;\n\n      var names = nameSources.map(function (ns) {\n        return ns.names.value[0] || \"\";\n      }).flatMap(function (p) {\n        return _this.namesFromProp(p);\n      }).filter(function (i) {\n        return i;\n      });\n      this.external[extTableId].variable_columns[this.variable_column_id] = names;\n      return names;\n    }\n  }, {\n    key: \"writeTableToProp\",\n    value: function writeTableToProp(extTableId, nameSources, restrictions) {\n      var viewData = this.dataModel.data[this.table_view];\n\n      var _this$variable_column = this.variable_column_id.split(\"/\"),\n          _this$variable_column2 = _toArray(_this$variable_column),\n          attr = _this$variable_column2[0],\n          path = _this$variable_column2.slice(1);\n\n      var prop_id = attr + \".\" + attr + \"/\" + path.join(\"/\"); // Change id for dynamic views\n\n      if (this.modelDefinition.views[this.table_view].size === -1) {\n        prop_id = this.table_view + \".\" + attr + \"/\" + path.join(\"/\");\n      }\n\n      var tableId = this.extractTableId(extTableId);\n\n      for (var v = 0; v < viewData.length; v++) {\n        viewData[v][this.table_attr][tableId] = {\n          value: [this.makeTable(extTableId, nameSources, restrictions)],\n          id: prop_id\n        };\n      } // Set object to trigger vue reactivity\n\n\n      this.dataModel.data[this.table_view] = viewData;\n    }\n  }, {\n    key: \"shouldOverwriteTable\",\n    value: function shouldOverwriteTable(extTableId) {\n      var _this2 = this;\n\n      // Don't overwrite if we can't find the table\n      if (!this.table_view) {\n        return false;\n      } // Overwrite if parameter isn't initialized yet\n\n\n      var data = this.dataModel.data[this.table_view];\n      var attr = data[0][this.table_attr];\n      if (!attr[this.variable_column_id]) return true;\n      var simputParam = attr[this.variable_column_id].value[0];\n      if (!simputParam) return true; // Overwrite if names on external differ from names on prop\n\n      var names = this.external[extTableId].variable_columns[this.variable_column_id];\n      var nameValues = simputParam.rows.map(function (row) {\n        return row.rowKeys[_this2.variable_column_id];\n      });\n\n      var uniqNameValues = _toConsumableArray(new Set(nameValues));\n\n      if (uniqNameValues.length !== names.length) {\n        return true;\n      }\n\n      var oldNames = _toConsumableArray(uniqNameValues).sort();\n\n      var newNames = _toConsumableArray(names).sort();\n\n      for (var i = 0; i < uniqNameValues.length; i++) {\n        if (newNames[i] !== oldNames[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"readNames\",\n    value: function readNames() {\n      var nameSources = [];\n      var views = this.dataModel.data[this.names_view]; // Read multiple views if dynamic view\n\n      for (var v = 0; v < views.length; v++) {\n        var view = views[v];\n\n        if (view[this.names_attr][this.names_id]) {\n          // Parameter is directly on view\n          // Find view name if view is dynamic\n          var propIsViewName = function propIsViewName(_ref) {\n            var _ref2 = _slicedToArray(_ref, 1),\n                id = _ref2[0];\n\n            return id.indexOf(\"/\") === -1;\n          };\n\n          var viewName = Object.entries(view[this.names_attr]).find(propIsViewName);\n          var parents = [];\n\n          if (viewName) {\n            var _viewName = _slicedToArray(viewName, 2),\n                id = _viewName[0],\n                prop = _viewName[1];\n\n            if (prop.value[0]) {\n              parents = _defineProperty({}, id, prop.value[0]);\n            }\n          }\n\n          nameSources = nameSources.concat({\n            parents: parents,\n            names: view[this.names_attr][this.names_id]\n          });\n        } else {\n          // Parameter is nested within a table\n          for (var p in view[this.names_attr]) {\n            var param = view[this.names_attr][p]; // If param is a table\n\n            var simputParam = param.value[0];\n\n            if (simputParam && simputParam.rows) {\n              for (var r in simputParam.rows) {\n                var tableHasNames = simputParam.rows[r].rowValues[this.names_id];\n                if (tableHasNames) nameSources = nameSources.concat({\n                  parents: simputParam.rows[r].rowKeys,\n                  names: simputParam.rows[r].rowValues[this.names_id].data\n                });\n              }\n            }\n          }\n        }\n      }\n\n      return nameSources;\n    } // **********************************************\n    // ********** Helpers (Pure functions) **********\n    // **********************************************\n\n  }, {\n    key: \"getSparseRestrictions\",\n    value: function getSparseRestrictions() {\n      var self = this;\n\n      var removeDense = function removeDense(_ref3, changedName) {\n        var targetTableNames = _ref3.rowKeys;\n        return Object.values(changedName).some(function (nameList) {\n          var parentsMatch = Object.entries(nameList.parents).every(function (_ref4) {\n            var _ref5 = _slicedToArray(_ref4, 2),\n                key = _ref5[0],\n                value = _ref5[1];\n\n            return targetTableNames[key] === value;\n          });\n\n          var longestKey = function longestKey(_ref6, _ref7) {\n            var _ref8 = _slicedToArray(_ref6, 1),\n                firstKey = _ref8[0];\n\n            var _ref9 = _slicedToArray(_ref7, 1),\n                secondKey = _ref9[0];\n\n            return secondKey.length - firstKey.length;\n          };\n\n          var _Object$entries$sort = Object.entries(targetTableNames).sort(longestKey),\n              _Object$entries$sort2 = _slicedToArray(_Object$entries$sort, 1),\n              _Object$entries$sort3 = _slicedToArray(_Object$entries$sort2[0], 2),\n              tableValue = _Object$entries$sort3[1];\n\n          var changedValues = nameList.names.value.flatMap(self.namesFromProp).filter(function (i) {\n            return i;\n          });\n          var valuesMatch = changedValues.includes(tableValue);\n          return parentsMatch && valuesMatch;\n        });\n      };\n\n      return [removeDense];\n    }\n  }, {\n    key: \"getMatchRestrictions\",\n    value: function getMatchRestrictions(match_condition, table_view, table_attr, dataModel) {\n      // We restrict the rows in a target table based on\n      // a value from its sibling table (from same view)\n      // which may match a foreign name\n      var targetTableKey = this.variable_column_id;\n      var foreignNameKey = match_condition.foreignNameKey,\n          siblingParamKey = match_condition.siblingParamKey;\n      var conditions = []; // FIXME have sparsity conditions from dynamic view variables\n\n      var view = dataModel.data[table_view][0];\n\n      for (var p in view[table_attr]) {\n        var siblingParam = view[table_attr][p];\n        var isTable = siblingParam && siblingParam.value[0] && siblingParam.value[0].rows;\n\n        if (isTable) {\n          var _loop = function _loop(r) {\n            var siblingRow = siblingParam.value[0].rows[r];\n            var siblingValue = siblingRow.rowValues[siblingParamKey];\n\n            if (siblingValue && siblingValue.data.value[0]) {\n              var removeMismatch = function removeMismatch(_ref10, foreignNamesAndParents) {\n                var targetTableNames = _ref10.rowKeys;\n\n                // Existing parflow conditions have only 1 rowKey; hardcoding 0\n                var _Object$entries$ = _slicedToArray(Object.entries(siblingRow.rowKeys)[0], 2),\n                    siblingId = _Object$entries$[0],\n                    siblingName = _Object$entries$[1];\n\n                var siblingNameMatches = targetTableNames[siblingId] === siblingName; // Existing parflow conditions have only 1 rowKey; find() gets first (only)\n\n                var valuesMatch = foreignNamesAndParents.find(function (_ref11) {\n                  var parents = _ref11.parents;\n                  return parents[foreignNameKey] === siblingValue.data.value[0];\n                });\n\n                if (!valuesMatch || !valuesMatch.names) {\n                  return false;\n                }\n\n                var foreignNameMatches = valuesMatch.names.value[0] && valuesMatch.names.value[0].includes(targetTableNames[targetTableKey]);\n                return siblingNameMatches || !foreignNameMatches;\n              };\n\n              conditions.push(removeMismatch);\n            }\n          };\n\n          // Read conditions from table\n          for (var r in siblingParam.value[0].rows) {\n            _loop(r);\n          }\n        }\n      }\n\n      return conditions;\n    }\n  }, {\n    key: \"makeTable\",\n    value: function makeTable(extTableId, nameSources, restrictions) {\n      var rows = [];\n      var tableDomain = this.external[extTableId];\n      var row_permutations = this.rowSectionCombinations(tableDomain.variable_columns);\n\n      var _loop2 = function _loop2(r) {\n        var permutation = row_permutations[r];\n        var valueCells = {};\n\n        for (var c in tableDomain.columns) {\n          var column = tableDomain.columns[c];\n          var ui = Object.assign({}, column); // Widget selection\n\n          ui.propType = column.ui || column.propType || \"cell\";\n\n          if (column.type === \"enum\") {\n            ui.propType = \"enum\";\n          }\n\n          valueCells[column.id] = {\n            ui: ui,\n            data: {\n              value: []\n            },\n            show: function show() {\n              return true;\n            }\n          };\n        }\n\n        var newRow = {\n          rowKeys: permutation,\n          rowValues: valueCells\n        };\n\n        if (restrictions.every(function (r) {\n          return r(newRow, nameSources);\n        })) {\n          rows.push(newRow);\n        }\n      };\n\n      for (var r in row_permutations) {\n        _loop2(r);\n      }\n\n      return {\n        rows: rows\n      };\n    }\n  }, {\n    key: \"rowSectionCombinations\",\n    value: function rowSectionCombinations(sections) {\n      var recordList = [];\n\n      var _loop3 = function _loop3(key) {\n        var row_names = sections[key];\n        recordList.push(row_names.map(function (name) {\n          return _defineProperty({}, key, name);\n        }));\n      };\n\n      for (var key in sections) {\n        _loop3(key);\n      }\n\n      return this.combine(recordList);\n    }\n  }, {\n    key: \"combine\",\n    value: function combine(_ref13) {\n      var _ref14 = _toArray(_ref13),\n          head = _ref14[0],\n          _ref14$slice = _toArray(_ref14.slice(1)),\n          tailHead = _ref14$slice[0],\n          tailTail = _ref14$slice.slice(1);\n\n      // Modified from https://stackoverflow.com/a/57015870\n      if (!tailHead) return head;\n      var combined = tailHead.reduce(function (acc, x) {\n        return acc.concat(head.map(function (h) {\n          return Object.assign({}, x, h);\n        }));\n      }, []);\n      return this.combine([combined].concat(_toConsumableArray(tailTail)));\n    }\n  }, {\n    key: \"findTargetViewName\",\n    value: function findTargetViewName(dataModel, attributeName) {\n      // Assume only one view has this attribute\n      var name = Object.keys(dataModel.data).find(function (viewKind) {\n        return dataModel.data[viewKind].find(function (viewInstance) {\n          return Object.keys(viewInstance).includes(attributeName);\n        });\n      });\n      return name;\n    }\n  }, {\n    key: \"namesFromProp\",\n    value: function namesFromProp(prop) {\n      if (Number.isInteger(prop)) {\n        return _toConsumableArray(Array(prop).keys()).map(function (i) {\n          return String(i + 1);\n        });\n      }\n\n      return prop.trim().split(\" \");\n    }\n  }, {\n    key: \"extractTableId\",\n    value: function extractTableId(externalTableId) {\n      var splitId = externalTableId.split(\"/\");\n      splitId.shift();\n      return splitId.join(\"/\");\n    }\n  }]);\n\n  return VariableTableUpdate;\n}();\n\n//# sourceURL=webpack:///./build/hooks.js?");

/***/ }),

/***/ "./build/index.js-exposed":
/*!********************************!*\
  !*** ./build/index.js-exposed ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if(!global[\"Simput\"]) global[\"Simput\"] = {};\nif(!global[\"Simput\"][\"types\"]) global[\"Simput\"][\"types\"] = {};\nmodule.exports = global[\"Simput\"][\"types\"][\"parflow\"] = __webpack_require__(/*! -!/home/drew/.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/babel-loader/lib??ref--9-0!./index.js */ \"../../../.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/babel-loader/lib/index.js?!./build/index.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/webpack/buildin/global.js */ \"../../../.nvm/versions/node/v14.15.1/lib/node_modules/simput/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./build/index.js-exposed?");

/***/ }),

/***/ "./build/model.json":
/*!**************************!*\
  !*** ./build/model.json ***!
  \**************************/
/*! exports provided: output, defaultActiveView, order, views, definitions, external, default */
/***/ (function(module) {

eval("module.exports = {\"output\":{},\"defaultActiveView\":\"Core\",\"order\":[\"Core\",\"Bconditions\",\"Bconditions_InternalBC_Properties\",\"Bconditions_Patch_Properties\",\"Geom\",\"GeomInput_Properties\",\"Geom_Properties\",\"Metadata\",\"Netcdf\",\"Phase\",\"Run\",\"Solver\",\"Timing\"],\"views\":{\"Netcdf\":{\"label\":\"Netcdf\",\"attributes\":[\"NetCDF\"]},\"Metadata\":{\"label\":\"Metadata\",\"attributes\":[\"Metadata\"],\"hooks\":[{\"table_attr\":\"Metadata\",\"variable_column_id\":\"Metadata/Authors/author_name_\",\"match_condition\":null,\"names_id\":\"Metadata/Authors/Names\",\"names_attr\":\"Metadata\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Metadata\"}]},\"Run\":{\"label\":\"Run\",\"attributes\":[\"BaseRun\"]},\"Bconditions\":{\"label\":\"Bconditions\",\"attributes\":[\"InternalBC\",\"BCPressure\",\"BCSaturation\"],\"hooks\":[]},\"Bconditions_InternalBC_Properties\":{\"label\":\"Bconditions InternalBC Properties\",\"attributes\":[\"Bconditions_InternalBC_Properties\"],\"size\":-1,\"hooks\":[{\"type\":\"copyParameterToViewName\",\"attribute\":\"Bconditions_InternalBC_Properties.internal_bc_name_\"}]},\"Bconditions_Patch_Properties\":{\"label\":\"Bconditions Patch Properties\",\"attributes\":[\"Bconditions_Patch_Properties\"],\"size\":-1,\"hooks\":[{\"type\":\"copyParameterToViewName\",\"attribute\":\"Bconditions_Patch_Properties.patch_name_\"},{\"table_attr\":\"Bconditions_Patch_Properties\",\"variable_column_id\":\"Patch/patch_name_/BCPressure/interval_name_/point_number_\",\"match_condition\":null,\"names_id\":\"Patch/patch_name_/BCPressure/interval_name_/NumPoints\",\"names_attr\":\"Bconditions_Patch_Properties\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Bconditions_Patch_Properties\"},{\"table_attr\":\"Bconditions_Patch_Properties\",\"variable_column_id\":\"Patch/patch_name_/BCSaturation/phase_name_/point_number_\",\"match_condition\":null,\"names_id\":\"Patch/patch_name_/BCSaturation/phase_name_/NumPoints\",\"names_attr\":\"Bconditions_Patch_Properties\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Bconditions_Patch_Properties\"}]},\"Solver\":{\"label\":\"Solver\",\"attributes\":[\"Solver\",\"SILO\",\"KnownSolution\"],\"hooks\":[{\"table_attr\":\"Solver\",\"variable_column_id\":\"Solver/Linear/Preconditioner/precond_method_\",\"match_condition\":null,\"names_id\":\"Solver/Linear/Preconditioner\",\"names_attr\":\"Solver\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Solver\"}]},\"Core\":{\"label\":\"Core\",\"attributes\":[\"Process\",\"ComputationalGrid\"]},\"Geom\":{\"label\":\"Geom\",\"attributes\":[\"Domain\",\"ICSaturation\",\"ICPressure\",\"GeomInput\",\"Perm\",\"SpecificStorage\",\"dzScale\",\"Geom\",\"TopoSlopes\",\"TopoSlopesX\",\"TopoSlopesY\",\"CapPressurePhaseItem\",\"Mannings\",\"FBx\",\"FBy\",\"FBz\"],\"hooks\":[{\"table_attr\":\"TopoSlopesX\",\"variable_column_id\":\"TopoSlopesX/Geom/geom_name_\",\"match_condition\":null,\"names_id\":\"TopoSlopesX/GeomNames\",\"names_attr\":\"TopoSlopesX\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Geom\"},{\"table_attr\":\"TopoSlopesY\",\"variable_column_id\":\"TopoSlopesY/Geom/geom_name_\",\"match_condition\":null,\"names_id\":\"TopoSlopesY/GeomNames\",\"names_attr\":\"TopoSlopesY\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Geom\"},{\"table_attr\":\"Mannings\",\"variable_column_id\":\"Mannings/Geom/geom_name_\",\"match_condition\":null,\"names_id\":\"Mannings/GeomNames\",\"names_attr\":\"Mannings\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Geom\"}]},\"GeomInput_Properties\":{\"label\":\"GeomInput Properties\",\"attributes\":[\"GeomInput_Properties\"],\"size\":-1,\"hooks\":[{\"type\":\"copyParameterToViewName\",\"attribute\":\"GeomInput_Properties.geom_input_name_\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomName\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomName\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomNames\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomNames\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomNames\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"},{\"source_id\":\"GeomInput/geom_input_name_/GeomNames\",\"type\":\"ReadLocationsWriteDomainHook\",\"dependant_domains\":[\"ICSaturation/GeomNames\",\"ICPressure/GeomNames\",\"SpecificStorage/GeomNames\",\"dzScale/GeomNames\",\"Geom/Perm/Names\",\"Geom/Perm/TensorByGeom/Names\",\"Geom/Porosity/GeomNames\",\"Geom/Retardation/GeomNames\",\"TopoSlopesX/GeomNames\",\"TopoSlopesY/GeomNames\",\"CapPressurePhaseItem/GeomNames\",\"Mannings/GeomNames\",\"Phase/RelPerm/GeomNames\",\"Phase/Saturation/GeomNames\",\"Phase/phase_name_/HeatCapacity/GeomNames\",\"PhaseSources/phase_name_/GeomNames\",\"PhaseSources/GeomNames\"],\"names_view\":\"GeomInput_Properties\"}]},\"Geom_Properties\":{\"label\":\"Geom Properties\",\"attributes\":[\"Geom_Properties\"],\"size\":-1,\"hooks\":[{\"type\":\"copyParameterToViewName\",\"attribute\":\"Geom_Properties.geom_name_\"}]},\"Phase\":{\"label\":\"Phase\",\"attributes\":[\"Phase\",\"PhaseSources\",\"Contaminants\"],\"hooks\":[{\"table_attr\":\"Phase\",\"variable_column_id\":\"Phase/phase_name_\",\"match_condition\":null,\"names_id\":\"Phase/Names\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"PhaseSources\",\"variable_column_id\":\"PhaseSources/phase_name_\",\"match_condition\":null,\"names_id\":\"Phase/Names\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Geom_Properties\",\"variable_column_id\":\"Geom/geom_name_/ICSaturation/phase_name_\",\"match_condition\":null,\"names_id\":\"Phase/Names\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Bconditions_Patch_Properties\",\"variable_column_id\":\"Patch/patch_name_/BCSaturation/phase_name_\",\"match_condition\":null,\"names_id\":\"Phase/Names\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Bconditions_Patch_Properties\",\"variable_column_id\":\"Patch/patch_name_/BCPressure/interval_name_/phase_name_\",\"match_condition\":null,\"names_id\":\"Phase/Names\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Phase\",\"variable_column_id\":\"Phase/phase_name_/Geom/geom_name_\",\"match_condition\":null,\"names_id\":\"Phase/phase_name_/HeatCapacity/GeomNames\",\"names_attr\":\"Phase\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"PhaseSources\",\"variable_column_id\":\"PhaseSources/phase_name_/Geom/geom_input_name_\",\"match_condition\":null,\"names_id\":\"PhaseSources/phase_name_/GeomNames\",\"names_attr\":\"PhaseSources\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"PhaseSources\",\"variable_column_id\":\"PhaseSources/Geom/geom_input_name_\",\"match_condition\":null,\"names_id\":\"PhaseSources/GeomNames\",\"names_attr\":\"PhaseSources\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Contaminants\",\"variable_column_id\":\"Contaminants/contaminant_name_\",\"match_condition\":null,\"names_id\":\"Contaminants/Names\",\"names_attr\":\"Contaminants\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"},{\"table_attr\":\"Geom_Properties\",\"variable_column_id\":\"Geom/geom_name_/contaminant_name_\",\"match_condition\":null,\"names_id\":\"Contaminants/Names\",\"names_attr\":\"Contaminants\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Phase\"}]},\"Timing\":{\"label\":\"Timing\",\"attributes\":[\"TimingInfo\",\"TimeStep\",\"Cycle\"],\"hooks\":[{\"table_attr\":\"Cycle\",\"variable_column_id\":\"Cycle/cycle_name_\",\"match_condition\":null,\"names_id\":\"Cycle/Names\",\"names_attr\":\"Cycle\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Timing\"},{\"table_attr\":\"Cycle\",\"variable_column_id\":\"Cycle/cycle_name_/interval_name_\",\"match_condition\":null,\"names_id\":\"Cycle/cycle_name_/Names\",\"names_attr\":\"Cycle\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Timing\"},{\"table_attr\":\"Bconditions_Patch_Properties\",\"variable_column_id\":\"Patch/patch_name_/BCPressure/interval_name_\",\"match_condition\":null,\"names_id\":\"Cycle/cycle_name_/Names\",\"names_attr\":\"Cycle\",\"type\":\"ReadNamesWriteTableHook\",\"names_view\":\"Timing\"}]}},\"definitions\":{\"NetCDF\":{\"label\":\"NetCDF\",\"parameters\":[{\"id\":\"NetCDF/NumStepsPerFile\",\"label\":\"NumStepsPerFile\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets number of time steps user wishes to output in a NetCDF4 file. Once the time step count increases beyond this number, a new file is automatically created.\",\"handlers\":[]},{\"id\":\"NetCDF/WritePressure\",\"label\":\"WritePressure\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets pressure variable to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteSaturation\",\"label\":\"WriteSaturation\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets saturation variable to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteMannings\",\"label\":\"WriteMannings\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets Mannings coefficients to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteSubsurface\",\"label\":\"WriteSubsurface\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets subsurface data(permeabilities, porosity, specific storage) to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteSlopes\",\"label\":\"WriteSlopes\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets x and y slopes to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteMask\",\"label\":\"WriteMask\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets mask to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteDZMultiplier\",\"label\":\"WriteDZMultiplier\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets DZ multipliers to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteEvapTrans\",\"label\":\"WriteEvapTrans\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets Evaptrans to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteEvapTransSum\",\"label\":\"WriteEvapTransSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets Evaptrans sum to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteOverlandSum\",\"label\":\"WriteOverlandSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets overland sum to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/WriteOverlandBCFlux\",\"label\":\"WriteOverlandBCFlux\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets overland bc flux to be written in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/Chunking\",\"label\":\"Chunking\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key sets chunking for each time varying 3-D variable in NetCDF4 file.\",\"handlers\":[]},{\"id\":\"NetCDF/ChunkX\",\"label\":\"ChunkX\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets chunking size in x-direction.\",\"handlers\":[]},{\"id\":\"NetCDF/ChunkY\",\"label\":\"ChunkY\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets chunking size in y-direction.\",\"handlers\":[]},{\"id\":\"NetCDF/ChunkZ\",\"label\":\"ChunkZ\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets chunking size in z-direction.\",\"handlers\":[]},{\"id\":\"NetCDF/ROMIOhints\",\"label\":\"ROMIOhints\",\"size\":1,\"type\":\"string\",\"help\":\"This key sets ROMIO hints file to be passed on to NetCDF4 interface.If this key is set, the file must be present and readable in experiment directory.\",\"handlers\":[]},{\"id\":\"NetCDF/NodeLevelIO\",\"label\":\"NodeLevelIO\",\"size\":1,\"type\":\"bool\",\"help\":\"This key sets flag for node level collective I/O.\",\"handlers\":[]},{\"id\":\"NetCDF/EvapTransFileTransient\",\"label\":\"EvapTransFileTransient\",\"size\":1,\"type\":\"bool\",\"help\":\"This key sets flag for transient evaptrans forcing to be read from a NetCDF file.\",\"handlers\":[]},{\"id\":\"NetCDF/EvapTrans/FileName\",\"label\":\"EvapTrans FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key sets flag for transient evaptrans forcing to be read from a NetCDF file.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"NetCDF/Compression\",\"label\":\"Compression\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\" This key enables in-transit deflate compression for all NetCDF variables using zlib. To use this feature, NetCDF4 v4.7.4 must be available, which supports the necessary parallel zlib compression. The compression quality can be influenced by the chunk sizes and the overall data distribution. Compressed variables in NetCDF files can be opened in serial mode also within older versions of NetCDF4.\",\"handlers\":[]},{\"id\":\"NetCDF/CompressionLevel\",\"label\":\"CompressionLevel\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\" This key sets the deflate compression level (if NetCDF.Compression is enabled), which influence the overall compression quality. zlib supports values between 0 (no compression), 1 (fastest compression) - 9 (slowest compression,smallest files).\",\"handlers\":[]}]},\"Metadata\":{\"label\":\"Metadata\",\"parameters\":[{\"id\":\"Metadata/Title\",\"label\":\"Title\",\"size\":1,\"type\":\"string\",\"help\":\"Summary explaining that run\",\"handlers\":[]},{\"id\":\"Metadata/Description\",\"label\":\"Description\",\"size\":1,\"type\":\"string\",\"help\":\"More details on that run\",\"handlers\":[]},{\"id\":\"Metadata/DOI\",\"label\":\"DOI\",\"size\":1,\"type\":\"string\",\"help\":\"Digital Object Identifier System code\",\"handlers\":[]},{\"id\":\"Metadata/Authors/Names\",\"label\":\"Authors Names\",\"size\":1,\"type\":\"string\",\"help\":\"List of short names to reference a list of authors\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"MetadataAuthorItem\",\"location\":\".\"}]},{\"id\":\"Metadata/Authors/author_name_\",\"label\":\"Authors Author\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Metadata/Authors/author_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"BaseRun\":{\"label\":\"BaseRun\",\"parameters\":[{\"id\":\"BaseRun/FileVersion\",\"label\":\"FileVersion (REQUIRED)\",\"size\":1,\"type\":\"int\",\"default\":4,\"help\":\"This gives the value of the input file version number that this file fits. As development of the ParFlow code continues, the input file format may vary. We have thus included an input file format number as a way of verifying that the correct format type is being used. The user can check in the parflow/config/file_versions.h file to verify that the format number specified in the input file matches the defined value of PFIN_VERSION.\",\"handlers\":[]},{\"id\":\"BaseRun/Gravity\",\"label\":\"Gravity (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"Specifies the gravity constant to be used.\",\"handlers\":[]},{\"id\":\"BaseRun/UseClustering\",\"label\":\"UseClustering\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"Run a clustering algorithm to create boxes in index space for iteration. By default an octree representation is used for iteration, this may result in iterating over many nodes in the octree. Th UseClustering key will run a clustering algorithm to build a set of boxes for iteration. This does not always have a significant impact on performance and the clustering algorithm can be expensive to compute. For small problems and short running problems clustering is not recommended. Long running problems may or may not see a benefit. The result varies significantly based on the geometries in the problem. The Berger-Rigoutsos algorithm is currently used for clustering.\",\"handlers\":[]},{\"id\":\"BaseRun/OverlandFlowSpinUp\",\"label\":\"OverlandFlowSpinUp\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies that a simplified form of the overland flow boundary condition (Equation 5.17) be used in place of the full equation. This formulation removes lateral flow and drives and ponded water pressures to zero using a SeepageFace boundary condition. While this can be helpful in spinning up the subsurface, this is no longer coupled subsurface-surface flow. If set to zero (the default) this key behaves normally.\",\"handlers\":[]},{\"id\":\"BaseRun/OverlandFlowSpinUpDampP1\",\"label\":\"OverlandFlowSpinUpDampP1\",\"size\":1,\"type\":\"double\",\"default\":0,\"help\":\"This key sets P1 and provides exponential dampening to the pressure relationship in the overland flow equation by adding the following term: P2*exp[(pressure)*P2]\",\"handlers\":[]},{\"id\":\"BaseRun/OverlandFlowSpinUpDampP2\",\"label\":\"OverlandFlowSpinUpDampP2\",\"size\":1,\"type\":\"double\",\"default\":0,\"help\":\"This key sets P2 and provides exponential dampening to the pressure relationship in the overland flow equation by adding the following term: P2*exp[(pressure)*P2]\",\"handlers\":[]},{\"id\":\"BaseRun/OverlandFlowDiffusive\",\"label\":\"OverlandFlowDiffusive\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"Changes the overland flow formulation to diffusive wave if set to 1.\",\"handlers\":[]}]},\"InternalBC\":{\"label\":\"InternalBC\",\"parameters\":[{\"id\":\"InternalBC/Names\",\"label\":\"Names\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the names for the internal boundary conditions. At each named point, x, y and z will specify the coordinate locations and h will specify the hydraulic head value of the condition. This real location is “snapped” to the nearest gridpoint in ParFlow. NOTE: Currently, ParFlow assumes that internal boundary conditions and pressure wells are separated by at least one cell from any external boundary. The user should be careful of this when defining the input file and grid.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"InternalBCItem\"}]}]},\"BCPressure\":{\"label\":\"BCPressure\",\"parameters\":[{\"id\":\"BCPressure/PatchNames\",\"label\":\"PatchNames\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the names of patches on which pressure boundary conditions will be specified. Note that these must all be patches on the external boundary of the domain and these patches must “cover” that external boundary.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"BCItem\",\"location\":\"../Patch\"}]}]},\"BCSaturation\":{\"label\":\"BCSaturation\",\"parameters\":[{\"id\":\"BCSaturation/PatchNames\",\"label\":\"PatchNames\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the names of patches on which saturation boundary conditions will be specified. Note that these must all be patches on the external boundary of the domain and these patches must “cover” that external boundary.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"BCItem\",\"location\":\"../Patch\"}]}]},\"Bconditions_InternalBC_Properties\":{\"label\":\"Bconditions InternalBC Properties\",\"parameters\":[{\"id\":\"internal_bc_name_\",\"label\":\"Name\",\"size\":1,\"type\":\"string\",\"help\":\"User-defined instance from InternalBC Names\"},{\"id\":\"InternalBC/internal_bc_name_/X\",\"label\":\"X\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the x-coordinate, x, of the named, internal_bc_name, condition.\",\"handlers\":[]},{\"id\":\"InternalBC/internal_bc_name_/Y\",\"label\":\"Y\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the y-coordinate, y, of the named, internal_bc_name, condition.\",\"handlers\":[]},{\"id\":\"InternalBC/internal_bc_name_/Z\",\"label\":\"Z\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the z-coordinate, z, of the named, internal_bc_name, condition.\",\"handlers\":[]},{\"id\":\"InternalBC/internal_bc_name_/Value\",\"label\":\"Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of the named, internal_bc_name, condition.\",\"handlers\":[]}]},\"Bconditions_Patch_Properties\":{\"label\":\"Bconditions Patch Properties\",\"parameters\":[{\"id\":\"patch_name_\",\"label\":\"Name\",\"size\":1,\"type\":\"string\",\"help\":\"User-defined instance from Patch Names\"},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_\",\"label\":\"BCPressure Interval\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/phase_name_\",\"label\":\"BCPressure Interval Phase\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_/phase_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/point_number_\",\"label\":\"BCPressure Interval Point\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_/point_number_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/Type\",\"label\":\"BCPressure Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"DirEquilRefPatch\":\"DirEquilRefPatch\",\"DirEquilPLinear\":\"DirEquilPLinear\",\"FluxConst\":\"FluxConst\",\"FluxVolumetric\":\"FluxVolumetric\",\"PressureFile\":\"PressureFile\",\"FluxFile\":\"FluxFile\",\"OverlandFlow\":\"OverlandFlow\",\"OverlandFlowPFB\":\"OverlandFlowPFB\",\"SeepageFace\":\"SeepageFace\",\"OverlandKinematic\":\"OverlandKinematic\",\"OverlandDiffusive\":\"OverlandDiffusive\",\"ExactSolution\":\"ExactSolution\"},\"help\":\"This key specifies the type of boundary condition data given for patch patch_name. Possible values for this key are DirEquilRefPatch, DirEquilPLinear, FluxConst, FluxVolumetric, PressureFile, FluxFile, OverlandFlow, OverlandFlowPFB, SeepageFace, OverlandKinematic, OverlandDiffusive and ExactSolution. The choice DirEquilRefPatch specifies that the pressure on the specified patch will be in hydrostatic equilibrium with a constant reference pressure given on a reference patch. The choice DirEquilPLinear specifies that the pressure on the specified patch will be in hydrostatic equilibrium with pressure given along a piecewise line at elevation z = 0. The choice FluxConst defines a constant normal flux boundary condition through the domain patch. This flux must be specified in units of [L]=[T]. For Richards’ equation, fluxes must be specified as a mass flux and given as the above flux multiplied by the density. Thus, this choice of input type for a Richards’ equation problem has units of ([L]=[T])([M]=[L]3). The choice FluxVolumetric defines a volumetric flux boundary condition through the domain patch. The units should be consistent with all other user input for the problem. For Richards’ equation fluxes must be specified as a mass flux and given as the above flux multiplied by the density. The choice PressureFile defines a hydraulic head boundary condition that is read from a properly distributed .pfb file. Only the values needed for the patch are used. The choice FluxFile defines a flux boundary condition that is read form a properly distributed .pfb file defined on a grid consistent with the pressure field grid. Only the values needed for the patch are used. The choices OverlandFlow and OverlandFlowPFB both turn on fully-coupled overland flow routing as described in [40] and in § 5.5. The key OverlandFlow corresponds to a Value key with a positive or negative value, to indicate uniform fluxes (such as rainfall or evapotranspiration) over the entire domain while the key OverlandFlowPFB allows a .pfb file to contain grid-based, spatially-variable fluxes. The OverlandKinematic and OverlandDiffusive both turn on an kinematic and diffusive wave overland flow routing boundary that solve equation 5.18 and do the upwinding internally (i.e. assuming that the user provides cell face slopes, as opposed to the traditional cell centered slopes). The key SeepageFace simulates a boundary that allows flow to exit but keeps the surface pressure at zero. The choice ExactSolution specifies that an exact known solution is to be applied as a Dirichlet boundary condition on the respective patch. Note that this does not change according to any cycle. Instead, time dependence is handled by evaluating at the time the boundary condition value is desired. The solution is specified by using a predefined function (choices are described below). NOTE: These last six types of boundary condition input is for Richards’ equation cases only!\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/Cycle\",\"label\":\"BCPressure Cycle\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the time cycle to which boundary condition data for patch patch_name corresponds.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/RefGeom\",\"label\":\"BCPressure RefGeom\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the name of the solid on which the reference patch for the DirEquilRefPatch boundary condition data is given. Care should be taken to make sure the correct solid is specified in cases of layered domains.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/RefPatch\",\"label\":\"BCPressure RefPatch\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the reference patch on which the DirEquilRefPatch boundary condition data is given. This patch must be on the reference solid specified by the Patch.patch_name.BCPressure.RefGeom key.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_\",\"label\":\"BCSaturation Phase\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Patch/patch_name_/BCSaturation/phase_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/point_number_\",\"label\":\"BCSaturation Phase Point\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Patch/patch_name_/BCSaturation/phase_name_/point_number_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"Solver\":{\"label\":\"Solver\",\"parameters\":[{\"id\":\"Solver/AbsTol\",\"label\":\"AbsTol\",\"size\":1,\"type\":\"double\",\"default\":\"1e-9\",\"help\":\"This value gives the absolute tolerance for the linear solve algorithm.\",\"handlers\":[]},{\"id\":\"Solver/AdvectOrder\",\"label\":\"AdvectOrder\",\"size\":1,\"type\":\"int\",\"default\":2,\"help\":\"This key controls the order of the explicit method used in advancing the concentrations. This value can be either 1 for a standard upwind first order or 2 for a second order Godunov method.\",\"handlers\":[]},{\"id\":\"Solver/BetaFluid\",\"label\":\"BetaFluid\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/BetaFracture\",\"label\":\"BetaFracture\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/BetaPerm\",\"label\":\"BetaPerm\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/BetaPore\",\"label\":\"BetaPore\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/BoxSizePowerOf2\",\"label\":\"BoxSizePowerOf2\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/CFL\",\"label\":\"CFL\",\"size\":1,\"type\":\"double\",\"default\":0.7,\"help\":\"This key gives the value of the weight put on the computed CFL limit before computing a global timestep value. Values greater than 1 are not suggested and in fact because this is an approximation, values slightly less than 1 can also produce instabilities.\",\"handlers\":[]},{\"id\":\"Solver/CoarseSolve\",\"label\":\"CoarseSolve\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/CompCompress\",\"label\":\"CompCompress\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/DiagScale\",\"label\":\"DiagScale\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/DiagSolver\",\"label\":\"DiagSolver\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/Drop\",\"label\":\"Drop\",\"size\":1,\"type\":\"double\",\"default\":\"1e-8\",\"help\":\"This key gives a clipping value for data written to PFSB files. Data values greater than the negative of this value and less than the value itself are treated as zero and not written to PFSB files.\",\"handlers\":[]},{\"id\":\"Solver/DropTol\",\"label\":\"DropTol\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/EvapTrans/FileLooping\",\"label\":\"EvapTrans FileLooping\",\"size\":1,\"type\":\"bool\",\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/EvapTrans/FileName\",\"label\":\"EvapTrans FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies specifies filename for the distributed .pfb file that contains the flux values for Richards’ equation. This file has [T-1] units. For the steady-state option (Solver.EvapTransFile=True) this key should be the complete filename. For the transient option (Solver.EvapTransFileTransient=True then the filename is a header and ParFlow will load one file per timestep, with the form filename.00000.pfb.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Solver/EvapTransFile\",\"label\":\"EvapTransFile\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies specifies that the Flux terms for Richards’ equation are read in from a .pfb file. This file has [T-1] units. Note this key is for a steady-state flux and should not be used in conjunction with the transient key below.\",\"handlers\":[]},{\"id\":\"Solver/EvapTransFileTransient\",\"label\":\"EvapTransFileTransient\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies specifies that the Flux terms for Richards’ equation are read in from a series of flux .pfb file. Each file has [T-1] units. Note this key should not be used with the key above, only one of these keys should be set to True at a time, not both.\",\"handlers\":[]},{\"id\":\"Solver/Jacobian\",\"label\":\"Jacobian\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/LSM\",\"label\":\"LSM\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"none\":\"none\",\"CLM\":\"CLM\"},\"default\":[\"none\"],\"help\":\"This key specifies whether a land surface model, such as CLM, will be called each solver timestep. Choices for this key include none and CLM. Note that CLM must be compiled and linked at runtime for this option to be active.\",\"handlers\":[]},{\"id\":\"Solver/MaxConvergenceFailures\",\"label\":\"MaxConvergenceFailures\",\"size\":1,\"type\":\"int\",\"default\":3,\"help\":\"This key gives the maximum number of convergence failures allowed. Each convergence failure cuts the timestep in half and the solver tries to advance the solution with the reduced timestep. The default value is 3. Note that setting this value to a value greater than 9 may result in errors in how time cycles are calculated. Time is discretized in terms of the base time unit and if the solver begins to take very small timesteps smallerthanbasetimeunit1000 the values based on time cycles will be change at slightly incorrect times. If the problem is failing converge so poorly that a large number of restarts are required, consider setting the timestep to a smaller value.\",\"handlers\":[]},{\"id\":\"Solver/MaxIter\",\"label\":\"MaxIter\",\"size\":1,\"type\":\"int\",\"default\":1000000,\"help\":\"This key gives the maximum number of iterations that will be allowed for time-stepping. This is to prevent a run-away simulation.\",\"handlers\":[]},{\"id\":\"Solver/MaxLevels\",\"label\":\"MaxLevels\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/MaxMinNX\",\"label\":\"MaxMinNX\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/MaxMinNY\",\"label\":\"MaxMinNY\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/MaxMinNZ\",\"label\":\"MaxMinNZ\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/OverlandDiffusive/Epsilon\",\"label\":\"OverlandDiffusive Epsilon\",\"size\":1,\"type\":\"double\",\"default\":0.00001,\"help\":\"This key provides a minimum value for the Sf used in the OverlandDiffusive boundary condition.\",\"handlers\":[]},{\"id\":\"Solver/OverlandKinematic/Epsilon\",\"label\":\"OverlandKinematic Epsilon\",\"size\":1,\"type\":\"double\",\"default\":0.00001,\"help\":\"This key provides a minimum value for the Sf used in the OverlandKinematic boundary condition.\",\"handlers\":[]},{\"id\":\"Solver/PolyDegree\",\"label\":\"PolyDegree\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/PolyPC\",\"label\":\"PolyPC\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/PrintCLM\",\"label\":\"PrintCLM\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether the CLM writes two dimensional binary output files to a PFB binary format. Note that CLM must be compiled and linked at runtime for this option to be active. These files are all written according to the standard format used for all ParFlow variables, using the runname, and istep. Variables are either two-dimensional or over the number of CLM layers (default of ten).\",\"handlers\":[]},{\"id\":\"Solver/PrintConcentration\",\"label\":\"PrintConcentration\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the concentration data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintDZMultiplier\",\"label\":\"PrintDZMultiplier\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/PrintEvapTrans\",\"label\":\"PrintEvapTrans\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/PrintEvapTransSum\",\"label\":\"PrintEvapTransSum\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/PrintLSMSink\",\"label\":\"PrintLSMSink\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the flux array passed from CLM to ParFlow. Printing occurs at each DumpInterval time.\",\"handlers\":[]},{\"id\":\"Solver/PrintMannings\",\"label\":\"PrintMannings\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the flux array passed from CLM to ParFlow. Printing occurs at each DumpInterval time.\",\"handlers\":[]},{\"id\":\"Solver/PrintMask\",\"label\":\"PrintMask\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the flux array passed from CLM to ParFlow. Printing occurs at each DumpInterval time.\",\"handlers\":[]},{\"id\":\"Solver/PrintOverlandBCFlux\",\"label\":\"PrintOverlandBCFlux\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the flux array passed from CLM to ParFlow. Printing occurs at each DumpInterval time.\",\"handlers\":[]},{\"id\":\"Solver/PrintOverlandSum\",\"label\":\"PrintOverlandSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the flux array passed from CLM to ParFlow. Printing occurs at each DumpInterval time.\",\"handlers\":[]},{\"id\":\"Solver/PrintPressure\",\"label\":\"PrintPressure\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the pressure data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintSaturation\",\"label\":\"PrintSaturation\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the saturation data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintSlopes\",\"label\":\"PrintSlopes\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the saturation data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintSpecificStorage\",\"label\":\"PrintSpecificStorage\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the saturation data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintSubsurf\",\"label\":\"PrintSubsurf\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the subsurface data, Permeability and Porosity. The data is printed after it is generated and before the main time stepping loop - only once during the run. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintSubsurfData\",\"label\":\"PrintSubsurfData\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on printing of the subsurface data, Permeability and Porosity. The data is printed after it is generated and before the main time stepping loop - only once during the run. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintTop\",\"label\":\"PrintTop\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"?\",\"handlers\":[]},{\"id\":\"Solver/PrintVelocities\",\"label\":\"PrintVelocities\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the x,y, and z velocity data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/PrintWells\",\"label\":\"PrintWells\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on collection and printing of the well data. The data is collected at intervals given by values in the timing information section. Printing occurs at the end of the run when all collected data is written.\",\"handlers\":[]},{\"id\":\"Solver/WritePfbSlopes\",\"label\":\"WritePfbSlopes\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on collection and printing of the slopes into a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/WritePfbMannings\",\"label\":\"WritePfbMannings\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key is used to turn on collection and printing of the mannings coefficients into a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/RAPType\",\"label\":\"RAPType\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/RelTol\",\"label\":\"RelTol\",\"size\":1,\"type\":\"double\",\"default\":1,\"help\":\"This value gives the relative tolerance for the linear solve algorithm.\",\"handlers\":[]},{\"id\":\"Solver/SadvectOrder\",\"label\":\"SadvectOrder\",\"size\":1,\"type\":\"int\",\"default\":2,\"help\":\"This key controls the order of the explicit method used in advancing the concentrations. This value can be either 1 for a standard upwind first order or 2 for a second order Godunov method.\",\"handlers\":[]},{\"id\":\"Solver/SlopeAccountingCLM\",\"label\":\"SlopeAccountingCLM\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether the CLM allows for the inclusion of slopes when determining solar zenith angles. Note that CLM must be compiled and linked at runtime for this option to be active.\",\"handlers\":[]},{\"id\":\"Solver/Smoother\",\"label\":\"Smoother\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/Spinup\",\"label\":\"Spinup\",\"size\":1,\"type\":\"bool\",\"help\":\"[Type: boolean]\",\"handlers\":[]},{\"id\":\"Solver/Symmetric\",\"label\":\"Symmetric\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/TerrainFollowingGrid\",\"label\":\"TerrainFollowingGrid\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies that a terrain-following coordinate transform is used for solver Richards. This key sets x and y subsurface slopes to be the same as the Topographic slopes (a value of False sets these subsurface slopes to zero). These slopes are used in the Darcy fluxes to add a density, gravity -dependent term. This key will not change the output files (that is the output is still orthogonal) or the geometries (they will still follow the computational grid)– these two things are both to do items. This key only changes solver Richards, not solver Impes.\",\"handlers\":[]},{\"id\":\"Solver/TerrainFollowingGrid/SlopeUpwindFormulation\",\"label\":\"TerrainFollowingGrid SlopeUpwindFormulation\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Original\":\"Original\",\"Upwind\":\"Upwind\",\"UpwindSine\":\"UpwindSine\"},\"default\":[\"Original\"],\"help\":\"This key specifies optional modifications to the terrain following grid formulation (Equation 5.8) . Choices for this key are Original, Upwind, UpwindSine. Original is the original TFG formulation shown in Equation 5.8 in the manual. The Original option calculates the theta-x and theta-y for a cell face as the average of the two adjacent cell slopes (i.e. assuming a cell centered slope calculation). The Upwind option uses the the theta-x and theta-y of a cell directly without averaging (i.e. assuming a face centered slope calculation). The UpwindSine is the same as the Upwind option but it also removes the Sine term from 5.8. Note the UpwindSine option is for experimental purposes only and should not be used in standard simulations. Also note that the choice of upwind orOriginal formulation should consistent with the choice of overland flow boundary condition if overland flow is being used. The upwind and UpwindSine are consistent with OverlandDiffusive and OverlandKinematic while Original is consistent with OverlandFlow.\",\"handlers\":[]},{\"id\":\"Solver/TwoNorm\",\"label\":\"TwoNorm\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/Weight\",\"label\":\"Weight\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/WriteCLMBinary\",\"label\":\"WriteCLMBinary\",\"size\":1,\"type\":\"bool\",\"default\":true,\"help\":\"This key specifies whether the CLM writes two dimensional binary output files in a generic binary format. Note that CLM must be compiled and linked at runtime for this option to be active.\",\"handlers\":[]},{\"id\":\"Solver/Linear\",\"label\":\"Linear\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"MGSemi\":\"MGSemi\",\"PPCG\":\"PPCG\",\"PCG\":\"PCG\",\"CGHS\":\"CGHS\"},\"default\":[\"PCG\"],\"help\":\"This key specifies the linear solver used for solver IMPES. Choices for this key are MGSemi, PPCG, PCG, and CGHS. The choice MGSemi is an algebraic mulitgrid linear solver (not a preconditioned conjugate gradient) which may be less robust than PCG as described in [3]. The choice PPCG is a preconditioned conjugate gradient solver. The choice PCG is a conjugate gradient solver with a multigrid preconditioner. The choice CGHS is a conjugate gradient solver.\",\"handlers\":[]},{\"id\":\"Solver/Linear/KrylovDimension\",\"label\":\"Linear KrylovDimension\",\"size\":1,\"type\":\"int\",\"default\":10,\"help\":\"This key specifies the maximum number of vectors to be used in setting up the Krylov subspace in the GMRES iterative solver. These vectors are of problem size and it should be noted that large increases in this parameter can limit problem sizes. However, increasing this parameter can sometimes help nonlinear solver convergence.\",\"handlers\":[]},{\"id\":\"Solver/Linear/MaxRestarts\",\"label\":\"Linear MaxRestarts\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies the number of restarts allowed to the GMRES solver. Restarts start the development of the Krylov subspace over using the current iterate as the initial iterate for the next pass.\",\"handlers\":[]},{\"id\":\"Solver/Linear/MaxRestart\",\"label\":\"Linear MaxRestart\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies the number of restarts allowed to the GMRES solver. Restarts start the development of the Krylov subspace over using the current iterate as the initial iterate for the next pass.\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner\",\"label\":\"Linear Preconditioner\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"NoPC\":\"NoPC\",\"MGSemi\":\"MGSemi\",\"PFMG\":\"PFMG\",\"PFMGOctree\":\"PFMGOctree\",\"SMG\":\"SMG\"},\"default\":[\"MGSemi\"],\"help\":\"This key specifies which preconditioner to use. Currently, the three choices are NoPC, MGSemi, PFMG, PFMGOctree and SMG. The choice NoPC specifies that no preconditioner should be used. The choice MGSemi specifies a semi-coarsening multigrid algorithm which uses a point relaxation method. The choice SMG specifies a semi-coarsening multigrid algorithm which uses plane relaxations. This method is more robust than MGSemi, but generally requires more memory and compute time. The choice PFMGOctree can be more efficient for problems with large numbers of inactive cells.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"PrecondMethodItem\",\"location\":\"./Preconditioner\"}]},{\"id\":\"Solver/Linear/Preconditioner/SymmetricMat\",\"label\":\"Linear Preconditioner SymmetricMat\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Symmetric\":\"Symmetric\",\"Nonsymmetric\":\"Nonsymmetric\"},\"default\":[\"Symmetric\"],\"help\":\"This key specifies whether the preconditioning matrix is symmetric. Choices fo rthis key are Symmetric and Nonsymmetric. The choice Symmetric specifies that the symmetric part of the Jacobian will be used as the preconditioning matrix. The choice Nonsymmetric specifies that the full Jacobian will be used as the preconditioning matrix. NOTE: ONLY Symmetric CAN BE USED IF MGSemi IS THE SPECIFIED PRECONDITIONER!\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/PCMatrixType\",\"label\":\"Linear Preconditioner PCMatrixType\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"FullJacobian\":\"FullJacobian\",\"PFSymmetric\":\"PFSymmetric\"},\"help\":\"[Type: string]\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_\",\"label\":\"Linear Preconditioner Precond\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Solver/Linear/Preconditioner/precond_method_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Solver/NonlinearSolver\",\"label\":\"NonlinearSolver\",\"size\":1,\"type\":\"double\",\"help\":\"[Type: int]\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/VariableDz\",\"label\":\"Nonlinear VariableDz\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether dZ multipliers are to be used, the default is False. The default indicates a false or non-active variable dz and each layer thickness is 1.0 [L].\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/FlowBarrierX\",\"label\":\"Nonlinear FlowBarrierX\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether Flow Barriers are to be used in the X direction, the default is False. The default indicates a false or FBx value of one [-] everywhere in the domain.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/FlowBarrierY\",\"label\":\"Nonlinear FlowBarrierY\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether Flow Barriers are to be used in the Y direction, the default is False. The default indicates a false or FBy value of one [-] everywhere in the domain.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/FlowBarrierZ\",\"label\":\"Nonlinear FlowBarrierZ\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether Flow Barriers are to be used in the Z direction, the default is False. The default indicates a false or FBz value of one [-] everywhere in the domain.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/ResidualTol\",\"label\":\"Nonlinear ResidualTol\",\"size\":1,\"type\":\"double\",\"default\":\"1e-7\",\"help\":\"This key specifies the tolerance that measures how much the relative reduction in the nonlinear residual should be before nonlinear iterations stop. The magnitude of the residual is measured with the l1 (max) norm.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/StepTol\",\"label\":\"Nonlinear StepTol\",\"size\":1,\"type\":\"double\",\"default\":\"1e-7\",\"help\":\"This key specifies the tolerance that measures how small the difference between two consecutive nonlinear steps can be before nonlinear iterations stop.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/MaxIter\",\"label\":\"Nonlinear MaxIter\",\"size\":1,\"type\":\"int\",\"default\":15,\"help\":\"This key specifies the maximum number of nonlinear iterations allowed before iterations stop with a convergence failure.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/PrintFlag\",\"label\":\"Nonlinear PrintFlag\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"NoVerbosity\":\"NoVerbosity\",\"LowVerbosity\":\"LowVerbosity\",\"NormalVerbosity\":\"NormalVerbosity\",\"HighVerbosity\":\"HighVerbosity\"},\"default\":[\"HighVerbosity\"],\"help\":\"This key specifies the amount of informational data that is printed to the *.out.kinsol.log file. Choices for this key are NoVerbosity, LowVerbosity, NormalVerbosity and HighVerbosity. The choice NoVerbosity prints no statistics about the nonlinear convergence process. The choice LowVerbosity outputs the nonlinear iteration count, the scaled norm of the nonlinear function, and the number of function calls. The choice NormalVerbosity prints the same as for LowVerbosity and also the global strategy statistics. The choice HighVerbosity prints the same as for NormalVerbosity with the addition of further Krylov iteration statistics.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/EtaChoice\",\"label\":\"Nonlinear EtaChoice\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"EtaConstant\":\"EtaConstant\",\"Walker1\":\"Walker1\",\"Walker2\":\"Walker2\"},\"default\":[\"Walker2\"],\"help\":\"This key specifies how the linear system tolerance will be selected. The linear system is solved until a relative residual reduction of n is achieved. Linear residual norms are measured in the l^2 norm. Choices for this key include EtaConstant, Walker1 and Walker2. If the choice EtaConstant is specified, then n will be taken as constant. The choices Walker1 and Walker2 specify choices for n developed by Eisenstat and Walker (see reference in manual). For both of the last two choices, n is never allowed to be less than 1e-4.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/EtaValue\",\"label\":\"Nonlinear EtaValue\",\"size\":1,\"type\":\"double\",\"default\":\"1e-4\",\"help\":\"This key specifies the constant value of n for the EtaChoice key EtaConstant.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/EtaAlpha\",\"label\":\"Nonlinear EtaAlpha\",\"size\":1,\"type\":\"double\",\"default\":2,\"help\":\"This key specifies the value of alpha for the case of EtaChoice being Walker2.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/EtaGamma\",\"label\":\"Nonlinear EtaGamma\",\"size\":1,\"type\":\"double\",\"default\":0.9,\"help\":\"This key specifies the value of gamma for the case of EtaChoice being Walker2.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/UseJacobian\",\"label\":\"Nonlinear UseJacobian\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether the Jacobian will be used in matrix-vector products or whether a matrix-free version of the code will run. Choices for this key are False and True. Using the Jacobian will most likely decrease the number of nonlinear iterations but require more memory to run.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/DerivativeEpsilon\",\"label\":\"Nonlinear DerivativeEpsilon\",\"size\":1,\"type\":\"double\",\"default\":\"1e-7\",\"help\":\"This key specifies the value of epsilon used in approximating the action of the Jacobian on a vector with approximate directional derivatives of the nonlinear function. This parameter is only used when the UseJacobian key is False.\",\"handlers\":[]},{\"id\":\"Solver/Nonlinear/Globalization\",\"label\":\"Nonlinear Globalization\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"LineSearch\":\"LineSearch\",\"InexactNewton\":\"InexactNewton\"},\"default\":[\"LineSearch\"],\"help\":\"This key specifies the type of global strategy to use. Possible choices for this key are InexactNewton and LineSearch. The choice InexactNewton specifies no global strategy, and the choice LineSearch specifies that a line search strategy should be used where the nonlinear step can be lengthened or decreased to satisfy certain criteria.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloCLM\",\"label\":\"WriteSiloCLM\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key specifies whether the CLM writes two dimensional binary output files to a silo binary format. This data may be read in by VisIT and other visualization packages. Note that CLM and silo must be compiled and linked at runtime for this option to be active. These files are all written according to the standard format used for all ParFlow variables, using the runname, and istep. Variables are either two-dimensional or over the number of CLM layers (default of ten).\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloConcentration\",\"label\":\"WriteSiloConcentration\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the concentration data in silo binary format. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloDZMultiplier\",\"label\":\"WriteSiloDZMultiplier\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloEvapTrans\",\"label\":\"WriteSiloEvapTrans\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the evaporation and rainfall flux data using silo binary format. This data comes from either clm or from external calls to ParFlow such as WRF. This data is in units of [L3T-1]. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloEvapTransSum\",\"label\":\"WriteSiloEvapTransSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the evaporation and rainfall flux data using silo binary format as a running, cumulative amount. This data comes from either clm or from external calls to ParFlow such as WRF. This data is in units of [L3]. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloMannings\",\"label\":\"WriteSiloMannings\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the Manning’s roughness data in silo binary format. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloMask\",\"label\":\"WriteSiloMask\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the mask data using silo binary format. The mask contains values equal to one for active cells and zero for inactive cells. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloOverlandBCFlux\",\"label\":\"WriteSiloOverlandBCFlux\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloOverlandSum\",\"label\":\"WriteSiloOverlandSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify calculation and printing of the total overland outflow from the domain using silo binary format as a running cumulative amount. This is integrated along all domain boundaries and is calculated any location that slopes at the edge of the domain point outward. This data is in units of [L3]. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOConcentration\",\"label\":\"WriteSiloPMPIOConcentration\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIODZMultiplier\",\"label\":\"WriteSiloPMPIODZMultiplier\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOEvapTrans\",\"label\":\"WriteSiloPMPIOEvapTrans\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOEvapTransSum\",\"label\":\"WriteSiloPMPIOEvapTransSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOMannings\",\"label\":\"WriteSiloPMPIOMannings\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOMask\",\"label\":\"WriteSiloPMPIOMask\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOOverlandBCFlux\",\"label\":\"WriteSiloPMPIOOverlandBCFlux\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOOverlandSum\",\"label\":\"WriteSiloPMPIOOverlandSum\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOPressure\",\"label\":\"WriteSiloPMPIOPressure\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOSaturation\",\"label\":\"WriteSiloPMPIOSaturation\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOSlopes\",\"label\":\"WriteSiloPMPIOSlopes\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOSpecificStorage\",\"label\":\"WriteSiloPMPIOSpecificStorage\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOSubsurfData\",\"label\":\"WriteSiloPMPIOSubsurfData\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOTop\",\"label\":\"WriteSiloPMPIOTop\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPMPIOVelocities\",\"label\":\"WriteSiloPMPIOVelocities\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"[Type: boolean/string]\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloPressure\",\"label\":\"WriteSiloPressure\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the pressure data in silo binary format. The printing of the data is controlled by values in the timing information section. This data may be read in by VisIT and other visualization packages.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloSaturation\",\"label\":\"WriteSiloSaturation\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the saturation data using silo binary format. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloSlopes\",\"label\":\"WriteSiloSlopes\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the x adn y slope data in silo binary format. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloSpecificStorage\",\"label\":\"WriteSiloSpecificStorage\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the specific storage data in silo binary format. The printing of the data is controlled by values in the timing information section.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloSubsurfData\",\"label\":\"WriteSiloSubsurfData\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to specify printing of the subsurface data, Permeability and Porosity in silo binary file format. The data is printed after it is generated and before the main time stepping loop - only once during the run. This data may be read in by VisIT and other visualization packages.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloTop\",\"label\":\"WriteSiloTop\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the x,y, and z velocity data. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]},{\"id\":\"Solver/WriteSiloVelocities\",\"label\":\"WriteSiloVelocities\",\"size\":1,\"type\":\"bool\",\"default\":false,\"help\":\"This key is used to turn on printing of the x,y, and z velocity data in silo binary format. The printing of the data is controlled by values in the timing information section. The data is written as a PFB file.\",\"handlers\":[]}]},\"SILO\":{\"label\":\"SILO\",\"parameters\":[{\"id\":\"SILO/Filetype\",\"label\":\"Filetype\",\"size\":1,\"type\":\"string\",\"default\":\"PDB\",\"help\":\"This key is used to specify the SILO filetype. Allowed values are PDB and HDF5. Note that you must have configured SILO with HDF5 in order to use that option.\",\"handlers\":[]},{\"id\":\"SILO/CompressionOptions\",\"label\":\"CompressionOptions\",\"size\":1,\"type\":\"string\",\"help\":\"This key is used to specify the SILO compression options. See the SILO manual for the DB_SetCompression command for information on available options. NOTE: the options available are highly dependent on the configure options when building SILO.\",\"handlers\":[]}]},\"KnownSolution\":{\"label\":\"KnownSolution\",\"parameters\":[{\"id\":\"KnownSolution/Value\",\"label\":\"Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the constant value of the known solution for type Constant known solutions.\",\"handlers\":[]}]},\"Process\":{\"label\":\"Process\",\"parameters\":[{\"id\":\"Process/Topology/P\",\"label\":\"Topology P (REQUIRED)\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"P allocates the number of processes to the grid-cells in x.\",\"handlers\":[]},{\"id\":\"Process/Topology/Q\",\"label\":\"Topology Q (REQUIRED)\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"Q allocates the number of processes to the grid-cells in y.\",\"handlers\":[]},{\"id\":\"Process/Topology/R\",\"label\":\"Topology R (REQUIRED)\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"R allocates the number of processes to the grid-cells in z. Please note R should always be 1 if you are running with Solver Richards unless you are running a totally saturated domain (solver IMPES).\",\"handlers\":[]}]},\"ComputationalGrid\":{\"label\":\"ComputationalGrid\",\"parameters\":[{\"id\":\"ComputationalGrid/Lower/X\",\"label\":\"Lower X (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This assigns the lower x coordinate location for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/Lower/Y\",\"label\":\"Lower Y (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This assigns the lower y coordinate location for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/Lower/Z\",\"label\":\"Lower Z (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This assigns the lower z coordinate location for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/NX\",\"label\":\"NX (REQUIRED)\",\"size\":1,\"type\":\"int\",\"help\":\"This assigns the number of grid cells in the x direction for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/NY\",\"label\":\"NY (REQUIRED)\",\"size\":1,\"type\":\"int\",\"help\":\"This assigns the number of grid cells in the y direction for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/NZ\",\"label\":\"NZ (REQUIRED)\",\"size\":1,\"type\":\"int\",\"help\":\"This assigns the number of grid cells in the z direction for the computational grid.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/DX\",\"label\":\"DX (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This defines the size of grid cells in the x direction. Units are L and are defined by the units of the hydraulic conductivity used in the problem.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/DY\",\"label\":\"DY (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This defines the size of grid cells in the y direction. Units are L and are defined by the units of the hydraulic conductivity used in the problem.\",\"handlers\":[]},{\"id\":\"ComputationalGrid/DZ\",\"label\":\"DZ (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This defines the size of grid cells in the z direction. Units are L and are defined by the units of the hydraulic conductivity used in the problem.\",\"handlers\":[]}]},\"Domain\":{\"label\":\"Domain\",\"parameters\":[{\"id\":\"Domain/GeomName\",\"label\":\"GeomName (REQUIRED)\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies which of the named geometries is the problem domain.\",\"handlers\":[{\"type\":\"ChildHandler\",\"class_name\":\"TopoSlopesXItem\",\"location\":\"/TopoSlopesX/Geom\"},{\"type\":\"ChildHandler\",\"class_name\":\"TopoSlopesYItem\",\"location\":\"/TopoSlopesY/Geom\"},{\"type\":\"ChildHandler\",\"class_name\":\"ManningsGeomItem\",\"location\":\"/Mannings/Geom\"}]}]},\"ICSaturation\":{\"label\":\"ICSaturation\",\"parameters\":[{\"id\":\"ICSaturation/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\"},\"help\":\"This key specifies the type of initial condition that will be applied to different geometries for given phase, phase_name. The only key currently available is Constant. The choice Constant will apply constants values within geometries for the phase.\",\"handlers\":[]},{\"id\":\"ICSaturation/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/ICSaturation/GeomNames\"},\"help\":\"This key specifies the geometries on which an initial condition will be given if the type is set to Constant. Note that geometries listed later “overlay” geometries listed earlier.\",\"handlers\":[{\"type\":\"ListHandler\"}]}]},\"ICPressure\":{\"label\":\"ICPressure\",\"parameters\":[{\"id\":\"ICPressure/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/ICPressure/GeomNames\"},\"help\":\"This key specifies the geometry names on which the initial pressure data will be given. These geometries must comprise the entire domain. Note that conditions for regions that overlap other regions will have unpredictable results. The regions given must be disjoint.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"ICPressure/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"PFBFile\":\"PFBFile\",\"HydroStaticPatch\":\"HydroStaticPatch\",\"NCFile\":\"NCFile\"},\"help\":\"This key specifies the type of initial condition given. The choices for this key are Constant, HydroStaticDepth, HydroStaticPatch and PFBFile. The choice Constant specifies that the initial pressure will be constant over the regions given. The choice HydroStaticDepth specifies that the initial pressure within a region will be in hydrostatic equilibrium with a given pressure specified at a given depth. The choice HydroStaticPatch specifies that the initial pressure within a region will be in hydrostatic equilibrium with a given pressure on a specified patch. Note that all regions must have the same type of initial data - different regions cannot have different types of initial data. However, the parameters for the type may be different. The PFBFile specification means that the initial pressure will be taken as a spatially varying function given by data in a ParFlow binary (.pfb) file.\",\"handlers\":[]}]},\"GeomInput\":{\"label\":\"GeomInput\",\"parameters\":[{\"id\":\"GeomInput/Names\",\"label\":\"Names\",\"size\":1,\"type\":\"string\",\"help\":\"List of names to use for defining geometry regions\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomInputItem\",\"location\":\".\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomItem\",\"location\":\"/Geom\"}]}]},\"Perm\":{\"label\":\"Perm\",\"parameters\":[{\"id\":\"Perm/TensorType\",\"label\":\"TensorType\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"TensorByGeom\":\"TensorByGeom\",\"TensorByFile\":\"TensorByFile\"},\"help\":\"This key specifies whether the permeability tensor entries kx; ky and kz will be specified as three constants within a set of regions covering the domain or whether the entries will be specified cell-wise by files. The choices for this key are TensorByGeom and TensorByFile.\",\"handlers\":[]},{\"id\":\"Perm/Conditioning/FileName\",\"label\":\"Conditioning FileName\",\"size\":1,\"type\":\"string\",\"default\":\"NA\",\"help\":\"This key specifies the name of the file that contains the conditioning data. The default string NA indicates that conditioning data is not applicable.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]}]},\"SpecificStorage\":{\"label\":\"SpecificStorage\",\"parameters\":[{\"id\":\"SpecificStorage/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/SpecificStorage/GeomNames\"},\"help\":\"This key specifies all of the geometries on which a different specific storage value will be assigned. These geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"SpecificStorage/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\"},\"help\":\"This key specifies which method is to be used to assign specific storage data. The only choice currently available is Constant which indicates that a constant is to be assigned to all grid cells within a geometry.\",\"handlers\":[]}]},\"dzScale\":{\"label\":\"dzScale\",\"parameters\":[{\"id\":\"dzScale/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/dzScale/GeomNames\"},\"help\":\"This key specifies which problem domain is being applied a variable dz subsurface. These geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"dzScale/Type\",\"label\":\"Type\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies which method is to be used to assign variable vertical grid spacing. The choices currently available are Constant which indicates that a constant is to be assigned to all grid cells within a geometry, nzList which assigns all layers of a given model to a list value, and PFBFile which reads in values from a distributed pfb file.\",\"handlers\":[]},{\"id\":\"dzScale/nzListNumber\",\"label\":\"Nzlistnumber\",\"size\":1,\"type\":\"int\",\"help\":\"This key indicates the number of layers with variable dz in the subsurface. This value is the same as the ComputationalGrid.NZ key.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"CellNzItem\",\"location\":\"../Cell\"}]}]},\"Geom\":{\"label\":\"Geom\",\"parameters\":[{\"id\":\"Geom/Perm/Names\",\"label\":\"Perm Names\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Geom/Perm/Names\"},\"help\":\"This key specifies all of the geometries to which a permeability field will be assigned. These geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"Geom/Perm/TensorByGeom/Names\",\"label\":\"Perm TensorByGeom Names\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Geom/Perm/TensorByGeom/Names\"},\"help\":\"This key specifies all of the geometries to which permeability tensor entries will be assigned. These geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"Geom/Porosity/GeomNames\",\"label\":\"Porosity GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Geom/Porosity/GeomNames\"},\"help\":\"This key specifies all of the geometries to which a porosity will be assigned. These geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"Geom/Retardation/GeomNames\",\"label\":\"Retardation GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Geom/Retardation/GeomNames\"},\"help\":\"This key specifies all of the geometries to which the contaminants will have a retardation function applied.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomItem\",\"location\":\"..\"}]}]},\"TopoSlopes\":{\"label\":\"TopoSlopes\",\"parameters\":[{\"id\":\"TopoSlopes/Elevation/FileName\",\"label\":\"Elevation FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key is the name of the PFB file that contains elevations which ParFlow uses to derive slopes. This is optional but can be useful when post-processing terrain-following grids.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]}]},\"TopoSlopesX\":{\"label\":\"TopoSlopesX\",\"parameters\":[{\"id\":\"TopoSlopesX/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/TopoSlopesX/GeomNames\"},\"help\":\"This key specifies all of the geometries on which a different x topographic slope values will be assigned. Topographic slopes may be assigned by PFBFile or as Constant by geometry. These geometries must cover the entire upper surface of the computational domain.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"TopoSlopesXItem\",\"location\":\"./Geom\"}]},{\"id\":\"TopoSlopesX/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"PFBFile\":\"PFBFile\",\"NCFile\":\"NCFile\"},\"help\":\"This key specifies which method is to be used to assign topographic slopes. The choices currently available are Constant which indicates that a constant is to be assigned to all grid cells within a geometry and PFBFile which indicates that all values are read in from a distributed, grid-based ParFlow binary file. If NetCDF is used, NCFile can be specified, which will read in slopes from a NetCDF file.\",\"handlers\":[]},{\"id\":\"TopoSlopesX/FileName\",\"label\":\"FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the value assigned to all points be read in from a ParFlow binary file.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"TopoSlopesX/Geom/geom_name_\",\"label\":\"Geom Geom\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/TopoSlopesX/Geom/geom_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"TopoSlopesY\":{\"label\":\"TopoSlopesY\",\"parameters\":[{\"id\":\"TopoSlopesY/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/TopoSlopesY/GeomNames\"},\"help\":\"This key specifies all of the geometries on which a different y topographic slope values will be assigned. Topographic slopes may be assigned by PFBFile or as Constant by geometry. These geometries must cover the entire upper surface of the computational domain.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"TopoSlopesYItem\",\"location\":\"./Geom\"}]},{\"id\":\"TopoSlopesY/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"PFBFile\":\"PFBFile\",\"NCFile\":\"NCFile\"},\"help\":\"This key specifies which method is to be used to assign topographic slopes. The choices currently available are Constant which indicates that a constant is to be assigned to all grid cells within a geometry and PFBFile which indicates that all values are read in from a distributed, grid-based ParFlow binary file. If NetCDF is used, NCFile can be specified, which will read in slopes from a NetCDF file.\",\"handlers\":[]},{\"id\":\"TopoSlopesY/FileName\",\"label\":\"FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the value assigned to all points be read in from a ParFlow binary file.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"TopoSlopesY/Geom/geom_name_\",\"label\":\"Geom Geom\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/TopoSlopesY/Geom/geom_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"CapPressurePhaseItem\":{\"label\":\"CapPressurePhaseItem\",\"parameters\":[{\"id\":\"CapPressurePhaseItem/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\"},\"default\":[\"Constant\"],\"help\":\"This key specifies the capillary pressure between phase 0 and the named phase, phase_name. The only choice available is Constant which indicates that a constant capillary pressure exists between the phases.\",\"handlers\":[]},{\"id\":\"CapPressurePhaseItem/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/CapPressurePhaseItem/GeomNames\"},\"help\":\"This key specifies the geometries that capillary pressures will be computed for in the named phase, phase_name. Regions listed later “overlay” regions listed earlier. Any geometries not listed will be assigned 0:0 capillary pressure by ParFlow.\",\"handlers\":[{\"type\":\"ListHandler\"}]}]},\"Mannings\":{\"label\":\"Mannings\",\"parameters\":[{\"id\":\"Mannings/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Mannings/GeomNames\"},\"help\":\"This key specifies all of the geometries on which a different Mannings roughness value will be assigned. Mannings values may be assigned by PFBFile or as Constant by geometry. These geometries must cover the entire upper surface of the computational domain.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"ManningsGeomItem\",\"location\":\"./Geom\"}]},{\"id\":\"Mannings/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies which method is to be used to assign Mannings roughness data. The choices currently available are Constant which indicates that a constant is to be assigned to all grid cells within a geometry and PFBFile which indicates that all values are read in from a distributed, grid-based ParFlow binary file.\",\"handlers\":[]},{\"id\":\"Mannings/FileName\",\"label\":\"FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the name of the ParFlow binary file with Manning's values.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Mannings/Geom/geom_name_\",\"label\":\"Geom Geom\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Mannings/Geom/geom_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"FBx\":{\"label\":\"FBx\",\"parameters\":[{\"id\":\"FBx/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies which method is to be used to assign flow barriers in X. The only choice currently available is PFBFile which reads in values from a distributed pfb file.\",\"handlers\":[]}]},\"FBy\":{\"label\":\"FBy\",\"parameters\":[{\"id\":\"FBy/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies which method is to be used to assign flow barriers in Y. The only choice currently available is PFBFile which reads in values from a distributed pfb file.\",\"handlers\":[]}]},\"FBz\":{\"label\":\"FBz\",\"parameters\":[{\"id\":\"FBz/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies which method is to be used to assign flow barriers in Z. The only choice currently available is PFBFile which reads in values from a distributed pfb file.\",\"handlers\":[]}]},\"GeomInput_Properties\":{\"label\":\"GeomInput Properties\",\"parameters\":[{\"id\":\"geom_input_name_\",\"label\":\"Name\",\"size\":1,\"type\":\"string\",\"help\":\"User-defined instance from GeomInput Names\"},{\"id\":\"GeomInput/geom_input_name_/InputType\",\"label\":\"InputType\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"SolidFile\":\"SolidFile\",\"IndicatorField\":\"IndicatorField\",\"Box\":\"Box\"},\"help\":\"This defines the type for the geometry input with the given input name. This key must be one of: SolidFile, IndicatorField, or Box.\",\"handlers\":[]},{\"id\":\"GeomInput/geom_input_name_/GeomName\",\"label\":\"GeomName\",\"size\":1,\"type\":\"string\",\"help\":\"This is a name of a single geometry defined by the geometry input. This should be used for a geometry input type of Box, which only requires a single name.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomInputItem\",\"location\":\"..\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomItem\",\"location\":\"/Geom\"}]},{\"id\":\"GeomInput/geom_input_name_/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"type\":\"string\",\"help\":\"This is a list of the names of the geometries defined by the geometry input. For a geometry input type of Box, the singular GeomName should be used. For the SolidFile geometry type this should contain a list with the same number of geometries as were defined using GMS. The order of geometries in the SolidFile should match the names. For IndicatorField types you need to specify the value in the input field which matches the name using GeomInput.geom_input_name.Value.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomInputItem\",\"location\":\"..\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomItem\",\"location\":\"/Geom\"}]},{\"id\":\"GeomInput/geom_input_name_/FileName\",\"label\":\"FileName\",\"size\":1,\"type\":\"string\",\"help\":\"For IndicatorField and SolidFile geometry inputs, this key specifies the input filename which contains the field or solid information.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"GeomInput/geom_input_name_/Value\",\"label\":\"Value\",\"size\":1,\"type\":\"int\",\"help\":\"For IndicatorField geometry inputs, you need to specify the mapping between values in the input file and the geometry names. The named geometry will be defined wherever the input file is equal to the specified value.\",\"handlers\":[]}]},\"Geom_Properties\":{\"label\":\"Geom Properties\",\"parameters\":[{\"id\":\"geom_name_\",\"label\":\"Name\",\"size\":1,\"type\":\"string\",\"help\":\"User-defined instance from Geom Names\"},{\"id\":\"Geom/geom_name_/FileName\",\"label\":\"FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies some sort of filename for the specified geometry.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Lower/X\",\"label\":\"Lower X\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the lower X real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Lower/Y\",\"label\":\"Lower Y\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the lower Y real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Lower/Z\",\"label\":\"Lower Z\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the lower Z real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Upper/X\",\"label\":\"Upper X\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the upper X real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Upper/Y\",\"label\":\"Upper Y\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the upper Y real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Upper/Z\",\"label\":\"Upper Z\",\"size\":1,\"type\":\"double\",\"help\":\"This gives the upper Z real space coordinate value of the previously specified box geometry of name box_geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Patches\",\"label\":\"Patches\",\"size\":1,\"type\":\"string\",\"help\":\"Patches are defined on the surfaces of geometries. Currently you can only define patches on Box geometries and on the the first geometry in a SolidFile. For a Box the order is fixed (left right front back bottom top) but you can name the sides anything you want.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomItem\",\"location\":\"..\"}]},{\"id\":\"Geom/geom_name_/Perm/Type\",\"label\":\"Perm Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"TurnBands\":\"TurnBands\",\"ParGauss\":\"ParGauss\",\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies which method is to be used to assign permeability data to the named geometry, geometry_name. It must be either Constant, TurnBands, ParGauss, or PFBFile.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/Value\",\"label\":\"Perm Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/LambdaX\",\"label\":\"Perm LambdaX\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the x correlation length of the field generated for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/LambdaY\",\"label\":\"Perm LambdaY\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the y correlation length of the field generated for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/LambdaZ\",\"label\":\"Perm LambdaZ\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the z correlation length of the field generated for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/GeomMean\",\"label\":\"Perm GeomMean\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the geometric mean of the log normal field generated for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/Sigma\",\"label\":\"Perm Sigma\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the standard deviation of the normal field generated for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/Seed\",\"label\":\"Perm Seed\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"This key specifies the initial seed for the random number generator used to generate the field for the named geometry, geometry_name, if either the Turning Bands or Parallel Gaussian Simulator are chosen. This number must be positive.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/NumLines\",\"label\":\"Perm NumLines\",\"size\":1,\"type\":\"int\",\"default\":100,\"help\":\"This key specifies the number of lines to be used in the Turning Bands algorithm for the named geometry, geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/RZeta\",\"label\":\"Perm RZeta\",\"size\":1,\"type\":\"double\",\"default\":5,\"help\":\"This key specifies the resolution of the line processes, in terms of the minimum grid spacing, to be used in the Turning Bands algorithm for the named geometry, geometry_name. Large values imply high resolution.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/KMax\",\"label\":\"Perm KMax\",\"size\":1,\"type\":\"double\",\"default\":100,\"help\":\"This key specifies the the maximum normalized frequency, Kmax, to be used in the Turning Bands algorithm for the named geometry, geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/DelK\",\"label\":\"Perm DelK\",\"size\":1,\"type\":\"double\",\"default\":0.2,\"help\":\"This key specifies the normalized frequency increment to be used in the Turning Bands algorithm for the named geometry, geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/MaxNPts\",\"label\":\"Perm MaxNPts\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets limits on the number of simulated points in the search neighborhood to be used in the Parallel Gaussian Simulator for the named geometry, geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/MaxCpts\",\"label\":\"Perm MaxCpts\",\"size\":1,\"type\":\"int\",\"help\":\"This key sets limits on the number of external conditioning points in the search neighborhood to be used in the Parallel Gaussian Simulator for the named geometry, geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/LogNormal\",\"label\":\"Perm LogNormal\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Normal\":\"Normal\",\"Log\":\"Log\",\"NormalTruncated\":\"NormalTruncated\",\"LogTruncated\":\"LogTruncated\"},\"default\":[\"LogTruncated\"],\"help\":\"The key specifies when a normal, log normal, truncated normal or truncated log normal field is to be generated by the method for the named geometry, geometry_name. This value must be one of Normal, Log, NormalTruncated or LogTruncated and can be used with either Turning Bands or the Parallel Gaussian Simulator.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/StratType\",\"label\":\"Perm StratType\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Horizontal\":\"Horizontal\",\"Bottom\":\"Bottom\",\"Top\":\"Top\"},\"default\":[\"Bottom\"],\"help\":\"This key specifies the stratification of the permeability field generated by the method for the named geometry, geometry_name. The value must be one of Horizontal, Bottom or Top and can be used with either the Turning Bands or the Parallel Gaussian Simulator.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/LowCutoff\",\"label\":\"Perm LowCutoff\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the low cutoff value for truncating the generated field for the named geometry, geometry_name, when either the NormalTruncated or LogTruncated values are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/HighCutoff\",\"label\":\"Perm HighCutoff\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the high cutoff value for truncating the generated field for the named geometry, geometry_name, when either the NormalTruncated or LogTruncated values are chosen.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/MaxSearchRad\",\"label\":\"Perm MaxSearchRad\",\"size\":1,\"type\":\"int\",\"help\":\"A key to improve correlation structure of RF in testing.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/FileName\",\"label\":\"Perm FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies that permeability values for the specified geometry, geometry_name, are given according to a user-supplied description in the “ParFlow Binary” file whose filename is given as the value. For a description of the ParFlow Binary file format, see the manual. The ParFlow Binary file associated with the named geometry must contain a collection of permeability values corresponding in a one-to-one manner to the entire computational grid. That is to say, when the contents of the file are read into the simulator, a complete permeability description for the entire domain is supplied. Only those values associated with computational cells residing within the geometry (as it is represented on the computational grid) will be copied into data structures used during the course of a simulation. Thus, the values associated with cells outside of the geounit are irrelevant. For clarity, consider a couple of different scenarios. For example, the user may create a file for each geometry such that appropriate permeability values are given for the geometry and “garbage\\\" values (e.g., some flag value) are given for the rest of the computational domain. In this case, a separate binary file is specified for each geometry. Alternatively, one may place all values representing the permeability field on the union of the geometries into a single binary file. Note that the permeability values must be represented in precisely the same configuration as the computational grid. Then, the same file could be specified for each geounit in the input file. Or, the computational domain could be described as a single geouint (in the ParFlow input file) in which case the permeability values would be read in only once.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorValX\",\"label\":\"Perm TensorValX\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of kx for the geometry given by geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorValY\",\"label\":\"Perm TensorValY\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of ky for the geometry given by geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorValZ\",\"label\":\"Perm TensorValZ\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of kz for the geometry given by geometry_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorFileX\",\"label\":\"Perm TensorFileX\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies that kx values for the specified geometry, geometry_name, are given according to a user-supplied description in the “ParFlow Binary” file whose filename is given as the value. The only choice for the value of geometry_name is “domain”.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorFileY\",\"label\":\"Perm TensorFileY\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies that ky values for the specified geometry, geometry_name, are given according to a user-supplied description in the “ParFlow Binary” file whose filename is given as the value. The only choice for the value of geometry_name is “domain”.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Perm/TensorFileZ\",\"label\":\"Perm TensorFileZ\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies that kz values for the specified geometry, geometry_name, are given according to a user-supplied description in the “ParFlow Binary” file whose filename is given as the value. The only choice for the value of geometry_name is “domain”.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Porosity/Type\",\"label\":\"Porosity Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\"},\"help\":\"This key specifies which method is to be used to assign porosity data to the named geometry, geometry_name. The only choice currently available is Constant which indicates that a constant is to be assigned to all grid cells within a geometry.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Porosity/Value\",\"label\":\"Porosity Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Porosity/FileName\",\"label\":\"Porosity FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies that porosity values for the specified geometry, geometry_name, are given according to a user-supplied description in the “ParFlow Binary” file whose filename is given as the value. The only choice for the value of geometry_name is “domain”.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/SpecificStorage/Value\",\"label\":\"SpecificStorage Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/Value\",\"label\":\"RelPerm Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the constant relative permeability value on the specified geometry.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/Alpha\",\"label\":\"RelPerm Alpha\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the alpha parameter for the Van Genuchten function specified on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/Alpha/Filename\",\"label\":\"RelPerm Alpha Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the alpha parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/N\",\"label\":\"RelPerm N\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the alpha parameter for the Van Genuchten function specified on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/N/Filename\",\"label\":\"RelPerm N Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the N parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/NumSamplePoints\",\"label\":\"RelPerm NumSamplePoints\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies the number of sample points for a spline base interpolation table for the Van Genuchten function specified on geom_name. If this number is 0 (the default) then the function is evaluated directly. Using the interpolation table is faster but is less accurate.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/MinPressureHead\",\"label\":\"RelPerm MinPressureHead\",\"size\":1,\"type\":\"int\",\"help\":\"This key specifies the lower value for a spline base interpolation table for the Van Genuchten function specified on geom_name. The upper value of the range is 0. This value is used only when the table lookup method is used (NumSamplePoints is greater than 0).\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/A\",\"label\":\"RelPerm A\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the A parameter for the Haverkamp relative permeability on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/Gamma\",\"label\":\"RelPerm Gamma\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the gamma parameter for the Haverkamp relative permeability on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/Degree\",\"label\":\"RelPerm Degree\",\"size\":1,\"type\":\"int\",\"help\":\"This key specifies the degree of the polynomial for the Polynomial relative permeability given on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/RelPerm/InterpolationMethod\",\"label\":\"RelPerm InterpolationMethod\",\"size\":1,\"type\":\"string\",\"help\":\"Specify the interpolation method for the relative permeability.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/CapPressurePhase/Value\",\"label\":\"CapPressurePhase Value\",\"size\":1,\"type\":\"double\",\"default\":0,\"help\":\"This key specifies the value of the capillary pressure in the named geometry, geometry_name, for the named phase, phase_name. IMPORTANT NOTE: the code currently works only for capillary pressure equal zero.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/Value\",\"label\":\"Saturation Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the constant saturation value on the specified geometry.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/Alpha\",\"label\":\"Saturation Alpha\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the alpha parameter for the Van Genuchten function specified on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/Alpha/Filename\",\"label\":\"Saturation Alpha Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the alpha parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/N\",\"label\":\"Saturation N\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the alpha parameter for the Van Genuchten function specified on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/N/Filename\",\"label\":\"Saturation N Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the N parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/SRes\",\"label\":\"Saturation SRes\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the residual saturation on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/SRes/Filename\",\"label\":\"Saturation SRes Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the residual saturation parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/SSat\",\"label\":\"Saturation SSat\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the saturation at saturated conditions on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/SSat/Filename\",\"label\":\"Saturation SSat Filename\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the SSat parameters for the VanGenuchten function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/A\",\"label\":\"Saturation A\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the A parameter for the Haverkamp saturation on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/Gamma\",\"label\":\"Saturation Gamma\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the gamma parameter for the Haverkamp saturation on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/Degree\",\"label\":\"Saturation Degree\",\"size\":1,\"type\":\"int\",\"help\":\"This key specifies the degree of the polynomial for the Polynomial saturation given on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/Saturation/FileName\",\"label\":\"Saturation FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the name of the file containing saturation values for the domain. It is assumed that geom_name is “domain” for this key.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/dzScale/Value\",\"label\":\"Dzscale Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/dzScale/FileName\",\"label\":\"Dzscale FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies file to be read in for variable dz values for the given geometry, geometry_name, if the type was set to PFBFile.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ThermalConductivity/Value\",\"label\":\"ThermalConductivity Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the thermal conductivity value on the specified geometry.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ThermalConductivity/KDry\",\"label\":\"ThermalConductivity KDry\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the thermal conductivity under dry conditions on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ThermalConductivity/KDry/FileName\",\"label\":\"ThermalConductivity KDry FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the dry thermal conductivity function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ThermalConductivity/KWet\",\"label\":\"ThermalConductivity KWet\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the thermal conductivity under saturated conditions on geom_name.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ThermalConductivity/KWet/FileName\",\"label\":\"ThermalConductivity KWet FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies a pfb filename containing the wet thermal conductivity function cell-by-cell. The ONLY option for geom_name is \\\"domain.\\\"\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/FBx/FileName\",\"label\":\"FBx FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies file to be read in for the X flow barrier values for the domain, if the type was set to PFBFile.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/FBy/FileName\",\"label\":\"FBy FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies file to be read in for the Y flow barrier values for the domain, if the type was set to PFBFile.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/FBz/FileName\",\"label\":\"FBz FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies file to be read in for the Z flow barrier values for the domain, if the type was set to PFBFile.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/HeatCapacity/Value\",\"label\":\"HeatCapacity Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the heat capacity of the given geometry. Units are J*g^-1*C^-1.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICPressure/FileName\",\"label\":\"ICPressure FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the name of the file containing pressure values for the domain. It is assumed that geom_name is “domain” for this key.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICPressure/RefElevation\",\"label\":\"ICPressure RefElevation\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the reference elevation on which the reference pressure is given for type HydroStaticDepth initial pressures.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICPressure/RefGeom\",\"label\":\"ICPressure RefGeom\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the geometry on which the reference patch resides for type HydroStaticPatch initial pressures.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICPressure/RefPatch\",\"label\":\"ICPressure RefPatch\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the patch on which the reference pressure is given for type HydorStaticPatch initial pressures.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICPressure/Value\",\"label\":\"ICPressure Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the initial pressure value for type Constant initial pressures and the reference pressure value for types HydroStaticDepth and HydroStaticPatch.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/ICSaturation/phase_name_\",\"label\":\"ICSaturation Phase\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Geom/geom_name_/ICSaturation/phase_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Geom/geom_name_/contaminant_name_\",\"label\":\"Contaminant\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Geom/geom_name_/contaminant_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"Phase\":{\"label\":\"Phase\",\"parameters\":[{\"id\":\"Phase/Names\",\"label\":\"Names\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies the names of phases to be modeled. Currently only 1 or 2 phases may be modeled.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseNameItem\",\"location\":\".\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseSourceNameItem\",\"location\":\"/PhaseSources\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseConcenPhaseNameItem\",\"location\":\"/PhaseConcen\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"WellIntervalFluxPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Flux\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"ExtractionFluxPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Extraction/Flux\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"InjectionFluxPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Injection/Flux\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"InjectionConcentrationPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Injection/Concentration\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"ConcentrationPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Concentration\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"WellIntervalSaturationPhaseItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Saturation\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomICSaturationPhaseItem\",\"location\":\"/Geom/{GeomItem}/ICSaturation\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"BCSatPhaseItem\",\"location\":\"/Patch/{BCItem}/BCSaturation\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"BCPressIntPhaseItem\",\"location\":\"/Patch/{BCItem}/BCPressure/{BCPressureIntervalItem}\"}]},{\"id\":\"Phase/RelPerm/Type\",\"label\":\"RelPerm Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"VanGenuchten\":\"VanGenuchten\",\"Haverkamp\":\"Haverkamp\",\"Data\":\"Data\",\"Polynomial\":\"Polynomial\"},\"help\":\"This key specifies the type of relative permeability function that will be used on all specified geometries. Note that only one type of relative permeability may be used for the entire problem. However, parameters may be different for that type in different geometries. For instance, if the problem consists of three geometries, then VanGenuchten may be specified with three different sets of parameters for the three different geometries. However, once VanGenuchten is specified, one geometry cannot later be specified to have Data as its relative permeability. The possible values for this key are Constant, VanGenuchten, Haverkamp, Data, and Polynomial.\",\"handlers\":[]},{\"id\":\"Phase/RelPerm/GeomNames\",\"label\":\"RelPerm GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Phase/RelPerm/GeomNames\"},\"help\":\"This key specifies the geometries on which relative permeability will be given. The union of these geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"Phase/RelPerm/VanGenuchten/File\",\"label\":\"RelPerm VanGenuchten File\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies whether soil parameters for the VanGenuchten function are specified in a pfb file or by region. The options are either 0 for specification by region, or 1 for specification in a file. Note that either all parameters are specified in files (each has their own input file) or none are specified by files. Parameters specified by files are: alpha and N.\",\"handlers\":[]},{\"id\":\"Phase/Saturation/Type\",\"label\":\"Saturation Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"VanGenuchten\":\"VanGenuchten\",\"Haverkamp\":\"Haverkamp\",\"Data\":\"Data\",\"Polynomial\":\"Polynomial\",\"PFBFile\":\"PFBFile\"},\"help\":\"This key specifies the type of saturation function that will be used on all specified geometries. Note that only one type of saturation may be used for the entire problem. However, parameters may be different for that type in different geometries. For instance, if the problem consists of three geometries, then VanGenuchten may be specified with three different sets of parameters for the three different goemetries. However, once VanGenuchten is specified, one geometry cannot later be specified to have Data as its saturation. The possible values for this key are Constant, VanGenuchten, Haverkamp, Data, Polynomial and PFBFile.\",\"handlers\":[]},{\"id\":\"Phase/Saturation/GeomNames\",\"label\":\"Saturation GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Phase/Saturation/GeomNames\"},\"help\":\"This key specifies the geometries on which saturation will be given. The union of these geometries must cover the entire computational domain.\",\"handlers\":[{\"type\":\"ListHandler\"}]},{\"id\":\"Phase/Saturation/VanGenuchten/File\",\"label\":\"Saturation VanGenuchten File\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key specifies whether soil parameters for the VanGenuchten function are specified in a pfb file or by region. The options are either 0 for specification by region, or 1 for specification in a file. Note that either all parameters are specified in files (each has their own input file) or none are specified by files. Parameters specified by files are alpha, N, SRes, and SSat.\",\"handlers\":[]},{\"id\":\"Phase/ThermalConductivity/Function1/File\",\"label\":\"ThermalConductivity Function1 File\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies the file name for the thermal conductivity function.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_\",\"label\":\"Phase\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Phase/phase_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Phase/phase_name_/Geom/geom_name_\",\"label\":\"Phase Geom Geom\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Phase/phase_name_/Geom/geom_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"PhaseSources\":{\"label\":\"PhaseSources\",\"parameters\":[{\"id\":\"PhaseSources/phase_name_\",\"label\":\"Phase\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/PhaseSources/phase_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"PhaseSources/phase_name_/Geom/geom_input_name_\",\"label\":\"Phase Geom Geom_Input\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/PhaseSources/phase_name_/Geom/geom_input_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"PhaseSources/GeomNames\",\"label\":\"GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/PhaseSources/GeomNames\"},\"help\":\"This key specifies the names of the geometries on which source terms will be specified. This is used only for Constant type phase sources. Regions listed later \\\"overlay\\\" regions listed earlier.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseSourceGeomItem\",\"location\":\"./Geom\"}]},{\"id\":\"PhaseSources/Geom/geom_input_name_\",\"label\":\"Geom Geom_Input\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/PhaseSources/Geom/geom_input_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"Contaminants\":{\"label\":\"Contaminants\",\"parameters\":[{\"id\":\"Contaminants/Names\",\"label\":\"Names\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies the names of contaminants to be advected.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"ContNameItem\",\"location\":\".\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"GeomContItem\",\"location\":\"/Geom/{GeomItem}/\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"ConcentrationPhaseContItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Concentration/{ConcentrationPhaseItem}\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"InjectionConcentrationPhaseContaminantItem\",\"location\":\"/Wells/{WellItem}/{WellIntervalItem}/Injection/Concentration/{InjectionConcentrationPhaseItem}\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseConcenContaminantItem\",\"location\":\"/PhaseConcen/{PhaseConcenPhaseNameItem}/\"}]},{\"id\":\"Contaminants/contaminant_name_\",\"label\":\"Contaminant\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Contaminants/contaminant_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]},\"TimingInfo\":{\"label\":\"TimingInfo\",\"parameters\":[{\"id\":\"TimingInfo/BaseUnit\",\"label\":\"BaseUnit\",\"size\":1,\"type\":\"double\",\"help\":\"This key is used to indicate the base unit of time for entering time values. All time should be expressed as a multiple of this value. This should be set to the smallest interval of time to be used in the problem. For example, a base unit of “1” means that all times will be integer valued. A base unit of “0.5” would allow integers and fractions of 0.5 to be used for time input values. The rationale behind this restriction is to allow time to be discretized on some interval to enable integer arithmetic to be used when computing/comparing times. This avoids the problems associated with real value comparisons which can lead to events occurring at different timesteps on different architectures or compilers. This value is also used when describing “time cycling data” in, currently, the well and boundary condition sections. The lengths of the cycles in those sections will be integer multiples of this value, therefore it needs to be the smallest divisor which produces an integral result for every “real time” cycle interval length needed.\",\"handlers\":[]},{\"id\":\"TimingInfo/StartCount\",\"label\":\"StartCount\",\"size\":1,\"type\":\"int\",\"help\":\"This key is used to indicate the time step number that will be associated with the first advection cycle in a transient problem. The value -1 indicates that advection is not to be done. The value 0 indicates that advection should begin with the given initial conditions. Values greater than 0 are intended to mean “restart” from some previous “checkpoint” time-step, but this has not yet been implemented.\",\"handlers\":[]},{\"id\":\"TimingInfo/StartTime\",\"label\":\"StartTime (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This key is used to indicate the starting time for the simulation.\",\"handlers\":[]},{\"id\":\"TimingInfo/StopTime\",\"label\":\"StopTime (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This key is used to indicate the stopping time for the simulation.\",\"handlers\":[]},{\"id\":\"TimingInfo/DumpInterval\",\"label\":\"DumpInterval (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This key is the real time interval at which time-dependent output should be written. A value of 0 will produce undefined behavior. If the value is negative, output will be dumped out every n time steps, where n is the absolute value of the integer part of the value.\",\"handlers\":[]},{\"id\":\"TimingInfo/DumpIntervalExecutionTimeLimit\",\"label\":\"DumpIntervalExecutionTimeLimit\",\"size\":1,\"type\":\"int\",\"default\":0,\"help\":\"This key is used to indicate a wall clock time to halt the execution of a run. At the end of each dump interval the time remaining in the batch job is compared with the user supplied value, if remaining time is less than or equal to the supplied value the execution is halted. Typically used when running on batch systems with time limits to force a clean shutdown near the end of the batch job. Time units is seconds, a value of 0 (the default) disables the check. Currently only supported on SLURM based systems, “–with-slurm” must be specified at configure time to enable.\",\"handlers\":[]},{\"id\":\"TimingInfo/DumpAtEnd\",\"label\":\"DumpAtEnd\",\"size\":1,\"type\":\"bool\",\"help\":\"Not in manual, but found in indicator_field.tcl test\",\"handlers\":[]}]},\"TimeStep\":{\"label\":\"TimeStep\",\"parameters\":[{\"id\":\"TimeStep/Type\",\"label\":\"Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"Growth\":\"Growth\"},\"help\":\"This key must be one of: Constant or Growth. The value Constant defines a constant time step. The value Growth defines a time step that starts as dt0 and is defined for other steps as dtnew = gamma*dtold such that dtnew is less than or equal to dtmax and dtnew is greater than or equal to dtmin.\",\"handlers\":[]},{\"id\":\"TimeStep/Value\",\"label\":\"Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key is used only if a constant time step is selected and indicates the value of the time step for all steps taken.\",\"handlers\":[]},{\"id\":\"TimeStep/InitialStep\",\"label\":\"InitialStep\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the initial time step dt0 if the Growth type time step is selected.\",\"handlers\":[]},{\"id\":\"TimeStep/GrowthFactor\",\"label\":\"GrowthFactor\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the growth factor gamma by which a time step will be multiplied to get the new time step when the Growth type time step is selected.\",\"handlers\":[]},{\"id\":\"TimeStep/MaxStep\",\"label\":\"MaxStep\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the maximum time step allowed, dtmax, when the Growth type time step is selected.\",\"handlers\":[]},{\"id\":\"TimeStep/MinStep\",\"label\":\"MinStep\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the minimum time step allowed, dtmin, when the Growth type time step is selected.\",\"handlers\":[]}]},\"Cycle\":{\"label\":\"Cycle\",\"parameters\":[{\"id\":\"Cycle/Names\",\"label\":\"Names\",\"size\":1,\"type\":\"string\",\"help\":\"This key is used to specify the named time cycles to be used in a simulation. It is a list of names and each name defines a time cycle and the number of items determines the total number of time cycles specified. Each named cycle is described using a number of keys defined under Cycle.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"CycleItem\",\"location\":\".\"}]},{\"id\":\"Cycle/cycle_name_\",\"label\":\"Cycle\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Cycle/cycle_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]},{\"id\":\"Cycle/cycle_name_/interval_name_\",\"label\":\"Cycle Interval\",\"size\":1,\"type\":\"string\",\"help\":\"\",\"ui\":\"variable_table\",\"domain\":{\"dynamic\":true,\"external\":\"VariableTableDomain/Cycle/cycle_name_/interval_name_\"},\"default\":{\"rows\":[]},\"handlers\":[]}]}},\"external\":{\"VariableTableDomain/Metadata/Authors/author_name_\":{\"columns\":[{\"id\":\"Metadata/Authors/author_name_/Name\",\"label\":\"Authors Author Name\",\"size\":1,\"type\":\"string\",\"help\":\"Author full name like {first_name} {last_name}\",\"handlers\":[]},{\"id\":\"Metadata/Authors/author_name_/Email\",\"label\":\"Authors Author Email\",\"size\":1,\"type\":\"string\",\"help\":\"E-mail address\",\"handlers\":[]},{\"id\":\"Metadata/Authors/author_name_/Organization\",\"label\":\"Authors Author Organization\",\"size\":1,\"type\":\"string\",\"help\":\"Name of the company or research institute\",\"handlers\":[]},{\"id\":\"Metadata/Authors/author_name_/URL\",\"label\":\"Authors Author URL\",\"size\":1,\"type\":\"string\",\"help\":\"Link to web site or social media\",\"handlers\":[]}],\"variable_columns\":{\"Metadata/Authors/author_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_/phase_name_\":{\"columns\":[{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/phase_name_/IntValue\",\"label\":\"BCPressure Interval Phase IntValue\",\"size\":1,\"type\":\"double\",\"help\":\"Note that the reference conditions for types DirEquilPLinear and DirEquilRefPatch boundary conditions are for phase 0 only. This key specifies the constant pressure value along the interface with phase phase_name for cases with two phases present.\",\"handlers\":[]}],\"variable_columns\":{\"Patch/patch_name_/BCPressure/interval_name_\":[],\"Patch/patch_name_/BCPressure/interval_name_/phase_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_/point_number_\":{\"columns\":[{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/point_number_/Location\",\"label\":\"BCPressure Interval Point Location\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies a number between 0 and 1 which represents the location of a point on the line on which data is given for type DirEquilPLinear boundary conditions. Here 0 corresponds to the lower end of the line, and 1 corresponds to the upper end.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/point_number_/Value\",\"label\":\"BCPressure Interval Point Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the pressure value for phase 0 at point number point_number and z = 0 for type DirEquilPLinear boundary conditions. All pressure values on the patch are determined by first projecting the boundary condition coordinate onto the line, then linearly interpolating between the neighboring point pressure values on the line.\",\"handlers\":[]}],\"variable_columns\":{\"Patch/patch_name_/BCPressure/interval_name_\":[],\"Patch/patch_name_/BCPressure/interval_name_/point_number_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Patch/patch_name_/BCPressure/interval_name_\":{\"columns\":[{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/Value\",\"label\":\"BCPressure Interval Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the reference pressure value for the DirEquilRefPatch boundary condition or the constant flux value for the FluxConst boundary condition, or the constant volumetric flux for the FluxVolumetric boundary condition.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/XLower\",\"label\":\"BCPressure Interval XLower\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the lower x coordinate of a line in the xy-plane.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/YLower\",\"label\":\"BCPressure Interval YLower\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the lower y coordinate of a line in the xy-plane.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/XUpper\",\"label\":\"BCPressure Interval XUpper\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the upper x coordinate of a line in the xy-plane.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/YUpper\",\"label\":\"BCPressure Interval YUpper\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the upper y coordinate of a line in the xy-plane.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/NumPoints\",\"label\":\"BCPressure Interval NumPoints\",\"size\":1,\"type\":\"int\",\"help\":\"This key specifies the number of points on which pressure data is given along the line used in the type DirEquilPLinear boundary conditions.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"BCPressIntPointItem\"}]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/FileName\",\"label\":\"BCPressure Interval FileName\",\"size\":1,\"type\":\"string\",\"help\":\"This key specifies the name of a properly distributed .pfb file that contains boundary data to be read for types PressureFile and FluxFile. For flux data, the data must be defined over a grid consistent with the pressure field. In both cases, only the values needed for the patch will be used. The rest of the data is ignored.\",\"domain\":{\"dynamic\":true,\"external\":\"files\"},\"ui\":\"enum\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCPressure/interval_name_/PredefinedFunction\",\"label\":\"BCPressure Interval PredefinedFunction\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"X\":\"X\",\"XPlusYPlusZ\":\"XPlusYPlusZ\",\"X3Y2PlusSinXYPlus1\":\"X3Y2PlusSinXYPlus1\",\"X3Y4PlusX2PlusSinXYCosYPlus1\":\"X3Y4PlusX2PlusSinXYCosYPlus1\",\"XYZTPlus1\":\"XYZTPlus1\",\"XYZTPlus1PermTensor\":\"XYZTPlus1PermTensor\"},\"help\":\"This key specifies the predefined function that will be used to specify Dirichlet boundary conditions on patch patch_name. Note that this does not change according to any cycle. Instead, time dependence is handled by evaluating at the time the boundary condition value is desired. Choices for this key include X, XPlusYPlusZ, X3Y2PlusSinXYPlus1, X3Y4PlusX2PlusSinXYCosYPlus1, XYZTPlus1 and XYZTPlus1PermTensor.\",\"handlers\":[]}],\"variable_columns\":{\"Patch/patch_name_/BCPressure/interval_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Patch/patch_name_/BCSaturation/phase_name_/point_number_\":{\"columns\":[{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/point_number_/Location\",\"label\":\"BCSaturation Phase Point Location\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies a number between 0 and 1 which represents the location of a point on the line for which data is given in type DirEquilPLinear boundary conditions. The line is parameterized so that 0 corresponds to the lower end of the line, and 1 corresponds to the upper end.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/point_number_/Value\",\"label\":\"BCSaturation Phase Point Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the water-table height for the given point if type DirEquilPLinear boundary conditions are selected. All saturation values on the patch are determined by first projecting the water-table height value onto the line, then linearly interpolating between the neighboring water-table height values onto the line.\",\"handlers\":[]}],\"variable_columns\":{\"Patch/patch_name_/BCSaturation/phase_name_\":[],\"Patch/patch_name_/BCSaturation/phase_name_/point_number_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Patch/patch_name_/BCSaturation/phase_name_\":{\"columns\":[{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/Type\",\"label\":\"BCSaturation Phase Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"DirConstant\":\"DirConstant\",\"ConstantWTHeight\":\"ConstantWTHeight\",\"PLinearWTHeight\":\"PLinearWTHeight\"},\"help\":\"This key specifies the type of boundary condition data given for the given phase, phase_name, on the given patch patch_name. Possible values for this key are DirConstant, ConstantWTHeight and PLinearWTHeight. The choice DirConstant specifies that the saturation is constant on the whole patch. The choice ConstantWTHeight specifies a constant height of the water-table on the whole patch. The choice PLinearWTHeight specifies that the height of the water-table on the patch will be given by a piecewise linear function. Note: the types ConstantWTHeight and PLinearWTHeight assume we are running a 2-phase problem where phase 0 is the water phase.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/Value\",\"label\":\"BCSaturation Phase Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies either the constant saturation value if DirConstant is selected or the constant water-table height if ConstantWTHeight is selected.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/XLower\",\"label\":\"BCSaturation Phase XLower\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the lower x coordinate of a line in the xy-plane if type PLinearWTHeight boundary conditions are specified.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/YLower\",\"label\":\"BCSaturation Phase YLower\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the lower y coordinate of a line in the xy-plane if type PLinearWTHeight boundary conditions are specified.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/XUpper\",\"label\":\"BCSaturation Phase XUpper\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the upper x coordinate of a line in the xy-plane if type PLinearWTHeight boundary conditions are specified.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/YUpper\",\"label\":\"BCSaturation Phase YUpper\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the upper y coordinate of a line in the xy-plane if type PLinearWTHeight boundary conditions are specified.\",\"handlers\":[]},{\"id\":\"Patch/patch_name_/BCSaturation/phase_name_/NumPoints\",\"label\":\"BCSaturation Phase NumPoints\",\"size\":1,\"type\":\"int\",\"help\":\"This key specifies the number of points on which saturation data is given along the line used in the type DirEquilPLinear boundary conditions.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"BCSatPhasePointItem\"}]}],\"variable_columns\":{\"Patch/patch_name_/BCSaturation/phase_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Solver/Linear/Preconditioner/precond_method_\":{\"columns\":[{\"id\":\"Solver/Linear/Preconditioner/precond_method_/MaxIter\",\"label\":\"Linear Preconditioner Precond MaxIter\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"This key specifies the maximum number of iterations to take in solving the preconditioner system with precond_ method solver.\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_/MaxLevels\",\"label\":\"Linear Preconditioner Precond MaxLevels\",\"size\":1,\"type\":\"int\",\"help\":\"Max Levels\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_/NumPreRelax\",\"label\":\"Linear Preconditioner Precond NumPreRelax\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"This key specifies the number of relaxations to take before coarsening in the specified preconditioner method. Note that this key is only relevant to the SMG multigrid preconditioner.\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_/NumPostRelax\",\"label\":\"Linear Preconditioner Precond NumPostRelax\",\"size\":1,\"type\":\"int\",\"default\":1,\"help\":\"This key specifies the number of relaxations to take after coarsening in the specified preconditioner method. Note that this key is only relevant to the SMG multigrid preconditioner.\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_/Smoother\",\"label\":\"Linear Preconditioner Precond Smoother\",\"size\":1,\"type\":\"string\",\"help\":\"[Type: string]\",\"handlers\":[]},{\"id\":\"Solver/Linear/Preconditioner/precond_method_/RAPType\",\"label\":\"Linear Preconditioner Precond RAPType\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Galerkin\":\"Galerkin\",\"NonGalerkin\":\"NonGalerkin\"},\"default\":[\"NonGalerkin\"],\"help\":\"For the PFMG solver, this key specifies the Hypre RAP type. Valid values are Galerkin or NonGalerkin\",\"handlers\":[]}],\"variable_columns\":{\"Solver/Linear/Preconditioner/precond_method_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/TopoSlopesX/Geom/geom_name_\":{\"columns\":[{\"id\":\"TopoSlopesX/Geom/geom_name_/Value\",\"label\":\"Geom Geom Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]}],\"variable_columns\":{\"TopoSlopesX/Geom/geom_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/TopoSlopesY/Geom/geom_name_\":{\"columns\":[{\"id\":\"TopoSlopesY/Geom/geom_name_/Value\",\"label\":\"Geom Geom Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]}],\"variable_columns\":{\"TopoSlopesY/Geom/geom_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Mannings/Geom/geom_name_\":{\"columns\":[{\"id\":\"Mannings/Geom/geom_name_/Value\",\"label\":\"Geom Geom Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value assigned to all points in the named geometry, geometry_name, if the type was set to constant.\",\"handlers\":[]}],\"variable_columns\":{\"Mannings/Geom/geom_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Geom/geom_name_/ICSaturation/phase_name_\":{\"columns\":[{\"id\":\"Geom/geom_name_/ICSaturation/phase_name_/Value\",\"label\":\"ICSaturation Phase Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the initial condition value assigned to all points in the named geometry, geom_input_name, if the type was set to Constant.\",\"handlers\":[]}],\"variable_columns\":{\"Geom/geom_name_/ICSaturation/phase_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Geom/geom_name_/contaminant_name_\":{\"columns\":[{\"id\":\"Geom/geom_name_/contaminant_name_/Retardation/Type\",\"label\":\"Contaminant Retardation Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Linear\":\"Linear\"},\"help\":\"This key specifies which function is to be used to compute the retardation for the named contaminant, contaminant_ name, in the named geometry, geometry_name. The only choice currently available is Linear which indicates that a simple linear retardation function is to be used to compute the retardation.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/contaminant_name_/Retardation/Value\",\"label\":\"Contaminant Retardation Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the distribution coefficient for the linear function used to compute the retardation of the named contaminant, contaminant_name, in the named geometry, geometry_name. The value should be scaled by the density of the material in the geometry.\",\"handlers\":[]},{\"id\":\"Geom/geom_name_/contaminant_name_/Retardation/Rate\",\"label\":\"Contaminant Retardation Rate\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the distribution coefficient for the linear function used to compute the retardation of the named contaminant, contaminant_name, in the named geometry, geometry_name. The value should be scaled by the density of the material in the geometry.\",\"handlers\":[]}],\"variable_columns\":{\"Geom/geom_name_/contaminant_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Phase/phase_name_/Geom/geom_name_\":{\"columns\":[{\"id\":\"Phase/phase_name_/Geom/geom_name_/HeatCapacity/Value\",\"label\":\"Phase Geom Geom HeatCapacity Value\",\"size\":1,\"type\":\"double\",\"help\":\"This specifies the heat capacity value for the specified geometric unit.\",\"handlers\":[]}],\"variable_columns\":{\"Phase/phase_name_\":[],\"Phase/phase_name_/Geom/geom_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Phase/phase_name_\":{\"columns\":[{\"id\":\"Phase/phase_name_/Density/Type\",\"label\":\"Phase Density Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"EquationOfState\":\"EquationOfState\"},\"help\":\"This key specifies whether density will be a constant value or if it will be given by an equation of state of the form (rd)exp(cP), where P is pressure, rd is the density at atmospheric pressure, and c is the phase compressibility constant. This key must be either Constant or EquationOfState.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Density/Value\",\"label\":\"Phase Density Value\",\"size\":1,\"type\":\"double\",\"help\":\"This specifies the value of density if this phase was specified to have a constant density value for the phase phase_name.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Density/ReferenceDensity\",\"label\":\"Phase Density ReferenceDensity\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the reference density if an equation of state density function is specified for the phase phase_name.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Density/CompressibilityConstant\",\"label\":\"Phase Density CompressibilityConstant\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the phase compressibility constant if an equation of state density function is specified for the phase phase_name.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Viscosity/Type\",\"label\":\"Phase Viscosity Type (REQUIRED)\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\"},\"default\":[\"Constant\"],\"help\":\"This key specifies whether viscosity will be a constant value. Currently, the only choice for this key is Constant.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Viscosity/Value\",\"label\":\"Phase Viscosity Value (REQUIRED)\",\"size\":1,\"type\":\"double\",\"help\":\"This specifies the value of density if this phase was specified to have a constant density value for the phase phase_name.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Mobility/Type\",\"label\":\"Phase Mobility Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"Polynomial\":\"Polynomial\"},\"help\":\"This key specifies whether the mobility for phase_name will be a given constant or a polynomial of the form, (S-So)^a, where S is saturation, So is irreducible saturation, and a is some exponent. The possibilities for this key are Constant and Polynomial.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Mobility/Value\",\"label\":\"Phase Mobility Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the constant mobility value for phase phase_name.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Mobility/Exponent\",\"label\":\"Phase Mobility Exponent\",\"size\":1,\"type\":\"double\",\"default\":2,\"help\":\"This key specifies the exponent used in a polynomial representation of the relative permeability. Currently, only a value of 2.0 is allowed for this key.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/Mobility/IrreducibleSaturation\",\"label\":\"Phase Mobility IrreducibleSaturation\",\"size\":1,\"type\":\"double\",\"default\":0,\"help\":\"This key specifies the irreducible saturation used in a polynomial representation of the relative permeability. Currently, only a value of 0.0 is allowed for this key.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/HeatCapacity/GeomNames\",\"label\":\"Phase HeatCapacity GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/Phase/phase_name_/HeatCapacity/GeomNames\"},\"help\":\"This specifies the geometry names for setting the heat capacity.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseNameHeatGeomItem\",\"location\":\"/Phase/{PhaseNameItem}/Geom\"}]},{\"id\":\"Phase/phase_name_/HeatCapacity/Type\",\"label\":\"Phase HeatCapacity Type\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies the type of heat capacity.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/InternalEnergy/Type\",\"label\":\"Phase InternalEnergy Type\",\"size\":1,\"type\":\"string\",\"help\":\"This specifies the type of internal energy.\",\"handlers\":[]},{\"id\":\"Phase/phase_name_/InternalEnergy/Value\",\"label\":\"Phase InternalEnergy Value\",\"size\":1,\"type\":\"double\",\"help\":\"This specifies the value for the internal energy.\",\"handlers\":[]}],\"variable_columns\":{\"Phase/phase_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/PhaseSources/phase_name_/Geom/geom_input_name_\":{\"columns\":[{\"id\":\"PhaseSources/phase_name_/Geom/geom_input_name_/Value\",\"label\":\"Phase Geom Geom_Input Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of a constant source term applied to phase phase _name on geometry geom_name.\",\"handlers\":[]}],\"variable_columns\":{\"PhaseSources/phase_name_\":[],\"PhaseSources/phase_name_/Geom/geom_input_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/PhaseSources/phase_name_\":{\"columns\":[{\"id\":\"PhaseSources/phase_name_/Type\",\"label\":\"Phase Type\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"Constant\":\"Constant\",\"PredefinedFunction\":\"PredefinedFunction\"},\"help\":\"This key specifies the type of source to use for phase phase_name. Possible values for this key are Constant and PredefinedFunction. Constant type phase sources specify a constant phase source value for a given set of regions. PredefinedFunction type phase sources use a preset function (choices are listed below) to specify the source. Note that the PredefinedFunction type can only be used to set a single source over the entire domain and not separate sources over different regions.\",\"handlers\":[]},{\"id\":\"PhaseSources/phase_name_/GeomNames\",\"label\":\"Phase GeomNames\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"dynamic\":true,\"external\":\"EnumDomain/PhaseSources/phase_name_/GeomNames\"},\"help\":\"This key specifies the names of the geometries on which source terms will be specified. This is used only for Constant type phase sources. Regions listed later “overlay” regions listed earlier.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"PhaseSourcePhaseGeomItem\",\"location\":\"./Geom\"}]},{\"id\":\"PhaseSources/phase_name_/PredefinedFunction\",\"label\":\"Phase PredefinedFunction\",\"size\":1,\"ui\":\"enum\",\"domain\":{\"X\":\"X\",\"XPlusYPlusZ\":\"XPlusYPlusZ\",\"X3Y2PlusSinXYPlus1\":\"X3Y2PlusSinXYPlus1\",\"X3Y4PlusX2PlusSinXYCosYPlus1\":\"X3Y4PlusX2PlusSinXYCosYPlus1\",\"XYZTPlus1\":\"XYZTPlus1\",\"XYZTPlus1PermTensor\":\"XYZTPlus1PermTensor\"},\"help\":\"This key specifies which of the predefined functions will be used for the source. Possible values for this key are X, XPlusYPlusZ, X3Y2PlusSinXYPlus1, X3Y4PlusX2PlusSinXYCosYPlus1, XYZTPlus1 and XYZTPlus1PermTensor.\",\"handlers\":[]}],\"variable_columns\":{\"PhaseSources/phase_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/PhaseSources/Geom/geom_input_name_\":{\"columns\":[{\"id\":\"PhaseSources/Geom/geom_input_name_/Value\",\"label\":\"Geom Geom_Input Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the value of a constant source term applied to phase phase _name on geometry geom_name.\",\"handlers\":[]}],\"variable_columns\":{\"PhaseSources/Geom/geom_input_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Contaminants/contaminant_name_\":{\"columns\":[{\"id\":\"Contaminants/contaminant_name_/Degradation/Value\",\"label\":\"Contaminant Degradation Value\",\"size\":1,\"type\":\"double\",\"help\":\"This key specifies the half-life decay rate of the named contaminant, contaminant_name. At present only first- order decay reactions are implemented and it is assumed that one contaminant cannot decay into another.\",\"handlers\":[]}],\"variable_columns\":{\"Contaminants/contaminant_name_\":[]},\"table_labels\":{},\"table_order\":{}},\"VariableTableDomain/Cycle/cycle_name_/interval_name_\":{\"columns\":[{\"id\":\"Cycle/cycle_name_/interval_name_/Length\",\"label\":\"Interval Length\",\"size\":1,\"type\":\"int\",\"help\":\"This key is used to specify the length of a named time intervals. It is an integer multiplier of the value set for the TimingInfo.BaseUnit key described above. The total length of a given time cycle is the sum of all the intervals multiplied by the base unit.\",\"handlers\":[]}],\"variable_columns\":{\"Cycle/cycle_name_\":[],\"Cycle/cycle_name_/interval_name_\":[]},\"table_labels\":{\"Cycle/cycle_name_\":\"Cycles\",\"Cycle/cycle_name_/Names\":\"Names for Intervals\",\"Cycle/cycle_name_/Repeat\":\"Repititions\",\"Cycle/cycle_name_/interval_name_\":\"Intervals\",\"Cycle/cycle_name_/interval_name_/Length\":\"Interval Length\"},\"table_order\":{}},\"VariableTableDomain/Cycle/cycle_name_\":{\"columns\":[{\"id\":\"Cycle/cycle_name_/Names\",\"label\":\"Names for Intervals\",\"size\":1,\"type\":\"string\",\"help\":\"This key is used to specify the named time intervals for each cycle. It is a list of names and each name defines a time interval when a specific boundary condition is applied and the number of items determines the total number of intervals in that time cycle.\",\"handlers\":[{\"type\":\"ChildrenHandler\",\"class_name\":\"CycleIntItem\",\"location\":\".\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"WellIntervalItem\",\"location\":\"/Wells/{WellItem}\"},{\"type\":\"ChildrenHandler\",\"class_name\":\"BCPressureIntervalItem\",\"location\":\"/Patch/{BCItem}/BCPressure\"}]},{\"id\":\"Cycle/cycle_name_/Repeat\",\"label\":\"Repititions\",\"size\":1,\"type\":\"int\",\"help\":\"This key is used to specify the how many times a named time interval repeats. A positive value specifies a number of repeat cycles a value of -1 specifies that the cycle repeat for the entire simulation.\",\"handlers\":[]}],\"variable_columns\":{\"Cycle/cycle_name_\":[]},\"table_labels\":{\"Cycle/cycle_name_\":\"Cycles\",\"Cycle/cycle_name_/Names\":\"Names for Intervals\",\"Cycle/cycle_name_/Repeat\":\"Repititions\",\"Cycle/cycle_name_/interval_name_\":\"Intervals\",\"Cycle/cycle_name_/interval_name_/Length\":\"Interval Length\"},\"table_order\":{\"Cycle/cycle_name_/Names\":2,\"Cycle/cycle_name_/Repeat\":1}}}};\n\n//# sourceURL=webpack:///./build/model.json?");

/***/ })

/******/ });